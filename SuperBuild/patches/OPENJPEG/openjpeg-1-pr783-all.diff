diff --git a/src/lib/openjp2/CMakeLists.txt b/src/lib/openjp2/CMakeLists.txt
index 367a7a8..c02a994 100644
--- a/src/lib/openjp2/CMakeLists.txt
+++ b/src/lib/openjp2/CMakeLists.txt
@@ -29,6 +29,7 @@ set(OPENJPEG_SRCS
   ${CMAKE_CURRENT_SOURCE_DIR}/mct.h
   ${CMAKE_CURRENT_SOURCE_DIR}/mqc.c
   ${CMAKE_CURRENT_SOURCE_DIR}/mqc.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/mqc_inl.h
   ${CMAKE_CURRENT_SOURCE_DIR}/openjpeg.c
   ${CMAKE_CURRENT_SOURCE_DIR}/openjpeg.h
   ${CMAKE_CURRENT_SOURCE_DIR}/opj_clock.c
diff --git a/src/lib/openjp2/mqc.c b/src/lib/openjp2/mqc.c
index 4e409a7..7119c3a 100644
--- a/src/lib/openjp2/mqc.c
+++ b/src/lib/openjp2/mqc.c
@@ -70,28 +70,6 @@ Fill mqc->c with 1's for flushing
 @param mqc MQC handle
 */
 static void opj_mqc_setbits(opj_mqc_t *mqc);
-/**
-FIXME DOC
-@param mqc MQC handle
-@return 
-*/
-static INLINE OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *const mqc);
-/**
-FIXME DOC
-@param mqc MQC handle
-@return 
-*/
-static INLINE OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *const mqc);
-/**
-Input a byte
-@param mqc MQC handle
-*/
-static INLINE void opj_mqc_bytein(opj_mqc_t *const mqc);
-/**
-Renormalize mqc->a and mqc->c while decoding
-@param mqc MQC handle
-*/
-static INLINE void opj_mqc_renormd(opj_mqc_t *const mqc);
 /*@}*/
 
 /*@}*/
@@ -284,82 +262,6 @@ static void opj_mqc_setbits(opj_mqc_t *mqc) {
 	}
 }
 
-static INLINE OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *const mqc) {
-	OPJ_INT32 d;
-	if (mqc->a < (*mqc->curctx)->qeval) {
-		d = (OPJ_INT32)(1 - (*mqc->curctx)->mps);
-		*mqc->curctx = (*mqc->curctx)->nlps;
-	} else {
-		d = (OPJ_INT32)(*mqc->curctx)->mps;
-		*mqc->curctx = (*mqc->curctx)->nmps;
-	}
-	
-	return d;
-}
-
-static INLINE OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *const mqc) {
-	OPJ_INT32 d;
-	if (mqc->a < (*mqc->curctx)->qeval) {
-		mqc->a = (*mqc->curctx)->qeval;
-		d = (OPJ_INT32)(*mqc->curctx)->mps;
-		*mqc->curctx = (*mqc->curctx)->nmps;
-	} else {
-		mqc->a = (*mqc->curctx)->qeval;
-		d = (OPJ_INT32)(1 - (*mqc->curctx)->mps);
-		*mqc->curctx = (*mqc->curctx)->nlps;
-	}
-	
-	return d;
-}
-
-#ifdef MQC_PERF_OPT
-static INLINE void opj_mqc_bytein(opj_mqc_t *const mqc) {
-	unsigned int i = *((unsigned int *) mqc->bp);
-	mqc->c += i & 0xffff00;
-	mqc->ct = i & 0x0f;
-	mqc->bp += (i >> 2) & 0x04;
-}
-#else
-static void opj_mqc_bytein(opj_mqc_t *const mqc) {
-	if (mqc->bp != mqc->end) {
-		OPJ_UINT32 c;
-		if (mqc->bp + 1 != mqc->end) {
-			c = *(mqc->bp + 1);
-		} else {
-			c = 0xff;
-		}
-		if (*mqc->bp == 0xff) {
-			if (c > 0x8f) {
-				mqc->c += 0xff00;
-				mqc->ct = 8;
-			} else {
-				mqc->bp++;
-				mqc->c += c << 9;
-				mqc->ct = 7;
-			}
-		} else {
-			mqc->bp++;
-			mqc->c += c << 8;
-			mqc->ct = 8;
-		}
-	} else {
-		mqc->c += 0xff00;
-		mqc->ct = 8;
-	}
-}
-#endif
-
-static INLINE void opj_mqc_renormd(opj_mqc_t *const mqc) {
-	do {
-		if (mqc->ct == 0) {
-			opj_mqc_bytein(mqc);
-		}
-		mqc->a <<= 1;
-		mqc->c <<= 1;
-		mqc->ct--;
-	} while (mqc->a < 0x8000);
-}
-
 /* 
 ==========================================================
    MQ-Coder interface
@@ -585,25 +487,6 @@ OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc, OPJ_BYTE *bp, OPJ_UINT32 len) {
         return OPJ_TRUE;
 }
 
-OPJ_INT32 opj_mqc_decode(opj_mqc_t *const mqc) {
-	OPJ_INT32 d;
-	mqc->a -= (*mqc->curctx)->qeval;
-	if ((mqc->c >> 16) < (*mqc->curctx)->qeval) {
-		d = opj_mqc_lpsexchange(mqc);
-		opj_mqc_renormd(mqc);
-	} else {
-		mqc->c -= (*mqc->curctx)->qeval << 16;
-		if ((mqc->a & 0x8000) == 0) {
-			d = opj_mqc_mpsexchange(mqc);
-			opj_mqc_renormd(mqc);
-		} else {
-			d = (OPJ_INT32)(*mqc->curctx)->mps;
-		}
-	}
-
-	return d;
-}
-
 void opj_mqc_resetstates(opj_mqc_t *mqc) {
 	OPJ_UINT32 i;
 	for (i = 0; i < MQC_NUMCTXS; i++) {
diff --git a/src/lib/openjp2/mqc.h b/src/lib/openjp2/mqc.h
index 69a2d46..491ee50 100644
--- a/src/lib/openjp2/mqc.h
+++ b/src/lib/openjp2/mqc.h
@@ -77,11 +77,14 @@ typedef struct opj_mqc {
 	OPJ_BYTE *end;
 	opj_mqc_state_t *ctxs[MQC_NUMCTXS];
 	opj_mqc_state_t **curctx;
+	const OPJ_BYTE *lut_ctxno_zc_orient; /* lut_ctxno_zc shifted by 256 * bandno */
 #ifdef MQC_PERF_OPT
 	unsigned char *buffer;
 #endif
 } opj_mqc_t;
 
+#include "mqc_inl.h"
+
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
@@ -198,7 +201,7 @@ Decode a symbol
 @param mqc MQC handle
 @return Returns the decoded symbol (0 or 1)
 */
-OPJ_INT32 opj_mqc_decode(opj_mqc_t * const mqc);
+static INLINE OPJ_INT32 opj_mqc_decode(opj_mqc_t * const mqc);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/src/lib/openjp2/mqc_inl.h b/src/lib/openjp2/mqc_inl.h
new file mode 100644
index 0000000..882b59f
--- /dev/null
+++ b/src/lib/openjp2/mqc_inl.h
@@ -0,0 +1,159 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MQC_INL_H
+#define __MQC_INL_H
+/**
+FIXME DOC
+@param mqc MQC handle
+@return
+*/
+static INLINE OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *const mqc) {
+	OPJ_INT32 d;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		d = (OPJ_INT32)(1 - (*mqc->curctx)->mps);
+		*mqc->curctx = (*mqc->curctx)->nlps;
+	} else {
+		d = (OPJ_INT32)(*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nmps;
+	}
+
+	return d;
+}
+
+/**
+FIXME DOC
+@param mqc MQC handle
+@return
+*/
+static INLINE OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *const mqc) {
+	OPJ_INT32 d;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		mqc->a = (*mqc->curctx)->qeval;
+		d = (OPJ_INT32)(*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nmps;
+	} else {
+		mqc->a = (*mqc->curctx)->qeval;
+		d = (OPJ_INT32)(1 - (*mqc->curctx)->mps);
+		*mqc->curctx = (*mqc->curctx)->nlps;
+	}
+
+	return d;
+}
+
+/**
+Input a byte
+@param mqc MQC handle
+*/
+#ifdef MQC_PERF_OPT
+static INLINE void opj_mqc_bytein(opj_mqc_t *const mqc) {
+	unsigned int i = *((unsigned int *) mqc->bp);
+	mqc->c += i & 0xffff00;
+	mqc->ct = i & 0x0f;
+	mqc->bp += (i >> 2) & 0x04;
+}
+#else
+static INLINE void opj_mqc_bytein(opj_mqc_t *const mqc) {
+	if (mqc->bp != mqc->end) {
+		OPJ_UINT32 c;
+		if (mqc->bp + 1 != mqc->end) {
+			c = *(mqc->bp + 1);
+		} else {
+			c = 0xff;
+		}
+		if (*mqc->bp == 0xff) {
+			if (c > 0x8f) {
+				mqc->c += 0xff00;
+				mqc->ct = 8;
+			} else {
+				mqc->bp++;
+				mqc->c += c << 9;
+				mqc->ct = 7;
+			}
+		} else {
+			mqc->bp++;
+			mqc->c += c << 8;
+			mqc->ct = 8;
+		}
+	} else {
+		mqc->c += 0xff00;
+		mqc->ct = 8;
+	}
+}
+#endif
+
+/**
+Renormalize mqc->a and mqc->c while decoding
+@param mqc MQC handle
+*/
+static INLINE void opj_mqc_renormd(opj_mqc_t *const mqc) {
+	do {
+		if (mqc->ct == 0) {
+			opj_mqc_bytein(mqc);
+		}
+		mqc->a <<= 1;
+		mqc->c <<= 1;
+		mqc->ct--;
+	} while (mqc->a < 0x8000);
+}
+
+/**
+Decode a symbol
+@param mqc MQC handle
+@return Returns the decoded symbol (0 or 1)
+*/
+static INLINE OPJ_INT32 opj_mqc_decode(opj_mqc_t *const mqc) {
+	OPJ_INT32 d;
+	mqc->a -= (*mqc->curctx)->qeval;
+	if ((mqc->c >> 16) < (*mqc->curctx)->qeval) {
+		d = opj_mqc_lpsexchange(mqc);
+		opj_mqc_renormd(mqc);
+	} else {
+		mqc->c -= (*mqc->curctx)->qeval << 16;
+		if ((mqc->a & 0x8000) == 0) {
+			d = opj_mqc_mpsexchange(mqc);
+			opj_mqc_renormd(mqc);
+		} else {
+			d = (OPJ_INT32)(*mqc->curctx)->mps;
+		}
+	}
+
+	return d;
+}
+
+#endif /* __MQC_INL_H */
diff --git a/src/lib/openjp2/t1.c b/src/lib/openjp2/t1.c
index 1bf7205..e1097bf 100644
--- a/src/lib/openjp2/t1.c
+++ b/src/lib/openjp2/t1.c
@@ -39,26 +39,27 @@
 #include "opj_includes.h"
 #include "t1_luts.h"
 
+/* #define CONSISTENCY_CHECK */
+
 /** @defgroup T1 T1 - Implementation of the tier-1 coding */
 /*@{*/
 
 /** @name Local static functions */
 /*@{*/
 
-static INLINE OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f, OPJ_UINT32 orient);
+static INLINE OPJ_BYTE opj_t1_getctxno_zc(opj_mqc_t *mqc, OPJ_UINT32 f);
 static OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f);
 static INLINE OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f);
 static OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f);
 static OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x, OPJ_UINT32 bitpos);
 static OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x, OPJ_UINT32 bitpos);
-static void opj_t1_updateflags(opj_flag_t *flagsp, OPJ_UINT32 s, OPJ_UINT32 stride);
+static INLINE void opj_t1_updateflags(opj_flag_t *flagsp, OPJ_UINT32 s, OPJ_UINT32 stride);
 /**
 Encode significant pass
 */
 static void opj_t1_enc_sigpass_step(opj_t1_t *t1,
                                     opj_flag_t *flagsp,
                                     OPJ_INT32 *datap,
-                                    OPJ_UINT32 orient,
                                     OPJ_INT32 bpno,
                                     OPJ_INT32 one,
                                     OPJ_INT32 *nmsedec,
@@ -81,23 +82,27 @@ static void opj_t1_dec_sigpass_step(opj_t1_t *t1,
 static INLINE void opj_t1_dec_sigpass_step_raw(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t* colflagsp,
                 OPJ_INT32 *datap,
-                OPJ_INT32 orient,
                 OPJ_INT32 oneplushalf,
-                OPJ_INT32 vsc);
+                OPJ_INT32 vsc,
+                OPJ_INT32 row);
 static INLINE void opj_t1_dec_sigpass_step_mqc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t* colflagsp,
                 OPJ_INT32 *datap,
-                OPJ_INT32 orient,
-                OPJ_INT32 oneplushalf);
+                OPJ_INT32 oneplushalf,
+                OPJ_INT32 row,
+                OPJ_INT32 flags_stride);
 static INLINE void opj_t1_dec_sigpass_step_mqc_vsc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t* colflagsp,
                 OPJ_INT32 *datap,
-                OPJ_INT32 orient,
                 OPJ_INT32 oneplushalf,
-                OPJ_INT32 vsc);
+                OPJ_INT32 vsc,
+                OPJ_INT32 row);
 
 
 /**
@@ -105,7 +110,6 @@ Encode significant pass
 */
 static void opj_t1_enc_sigpass( opj_t1_t *t1,
                                 OPJ_INT32 bpno,
-                                OPJ_UINT32 orient,
                                 OPJ_INT32 *nmsedec,
                                 OPJ_BYTE type,
                                 OPJ_UINT32 cblksty);
@@ -116,16 +120,10 @@ Decode significant pass
 static void opj_t1_dec_sigpass_raw(
                 opj_t1_t *t1,
                 OPJ_INT32 bpno,
-                OPJ_INT32 orient,
                 OPJ_INT32 cblksty);
-static void opj_t1_dec_sigpass_mqc(
-                opj_t1_t *t1,
-                OPJ_INT32 bpno,
-                OPJ_INT32 orient);
 static void opj_t1_dec_sigpass_mqc_vsc(
                 opj_t1_t *t1,
-                OPJ_INT32 bpno,
-                OPJ_INT32 orient);
+                OPJ_INT32 bpno);
 
 
 
@@ -158,9 +156,6 @@ static void opj_t1_dec_refpass_raw(
                 opj_t1_t *t1,
                 OPJ_INT32 bpno,
                 OPJ_INT32 cblksty);
-static void opj_t1_dec_refpass_mqc(
-                opj_t1_t *t1,
-                OPJ_INT32 bpno);
 static void opj_t1_dec_refpass_mqc_vsc(
                 opj_t1_t *t1,
                 OPJ_INT32 bpno);
@@ -182,23 +177,28 @@ static void opj_t1_dec_refpass_step(opj_t1_t *t1,
 static INLINE void  opj_t1_dec_refpass_step_raw(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t *colflagsp,
                 OPJ_INT32 *datap,
                 OPJ_INT32 poshalf,
                 OPJ_INT32 neghalf,
-                OPJ_INT32 vsc);
+                OPJ_INT32 row);
 static INLINE void opj_t1_dec_refpass_step_mqc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t *colflagsp,
                 OPJ_INT32 *datap,
                 OPJ_INT32 poshalf,
-                OPJ_INT32 neghalf);
+                OPJ_INT32 neghalf,
+                OPJ_INT32 row);
 static INLINE void opj_t1_dec_refpass_step_mqc_vsc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t *colflagsp,
                 OPJ_INT32 *datap,
                 OPJ_INT32 poshalf,
                 OPJ_INT32 neghalf,
-                OPJ_INT32 vsc);
+                OPJ_INT32 vsc,
+                OPJ_INT32 row);
 
 
 
@@ -209,7 +209,6 @@ static void opj_t1_enc_clnpass_step(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
 		OPJ_INT32 *datap,
-		OPJ_UINT32 orient,
 		OPJ_INT32 bpno,
 		OPJ_INT32 one,
 		OPJ_INT32 *nmsedec,
@@ -221,30 +220,32 @@ Decode clean-up pass
 static void opj_t1_dec_clnpass_step_partial(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
+		opj_colflag_t *colflagsp,
 		OPJ_INT32 *datap,
-		OPJ_INT32 orient,
-		OPJ_INT32 oneplushalf);
+		OPJ_INT32 oneplushalf,
+		OPJ_INT32 row);
 static void opj_t1_dec_clnpass_step(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
+		opj_colflag_t *colflagsp,
 		OPJ_INT32 *datap,
-		OPJ_INT32 orient,
-		OPJ_INT32 oneplushalf);
+		OPJ_INT32 oneplushalf,
+		OPJ_INT32 row);
 static void opj_t1_dec_clnpass_step_vsc(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
+		opj_colflag_t *colflagsp,
 		OPJ_INT32 *datap,
-		OPJ_INT32 orient,
 		OPJ_INT32 oneplushalf,
 		OPJ_INT32 partial,
-		OPJ_INT32 vsc);
+		OPJ_INT32 vsc,
+		OPJ_INT32 row);
 /**
 Encode clean-up pass
 */
 static void opj_t1_enc_clnpass(
 		opj_t1_t *t1,
 		OPJ_INT32 bpno,
-		OPJ_UINT32 orient,
 		OPJ_INT32 *nmsedec,
 		OPJ_UINT32 cblksty);
 /**
@@ -253,7 +254,6 @@ Decode clean-up pass
 static void opj_t1_dec_clnpass(
 		opj_t1_t *t1,
 		OPJ_INT32 bpno,
-		OPJ_INT32 orient,
 		OPJ_INT32 cblksty);
 
 static OPJ_FLOAT64 opj_t1_getwmsedec(
@@ -305,8 +305,8 @@ static OPJ_BOOL opj_t1_allocate_buffers(   opj_t1_t *t1,
 
 /* ----------------------------------------------------------------------- */
 
-static OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f, OPJ_UINT32 orient) {
-	return lut_ctxno_zc[(orient << 8) | (f & T1_SIG_OTH)];
+static OPJ_BYTE opj_t1_getctxno_zc(opj_mqc_t *mqc, OPJ_UINT32 f) {
+	return mqc->lut_ctxno_zc_orient[(f & T1_SIG_OTH)];
 }
 
 static OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f) {
@@ -339,34 +339,73 @@ static OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x, OPJ_UINT32 bitpos) {
     return lut_nmsedec_ref0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
 }
 
-static void opj_t1_updateflags(opj_flag_t *flagsp, OPJ_UINT32 s, OPJ_UINT32 stride) {
+static INLINE void opj_t1_updateflags(opj_flag_t *flagsp, OPJ_UINT32 s, OPJ_UINT32 stride) {
 	opj_flag_t *np = flagsp - stride;
 	opj_flag_t *sp = flagsp + stride;
 
-	static const opj_flag_t mod[] = {
-		T1_SIG_S, T1_SIG_S|T1_SGN_S,
-		T1_SIG_E, T1_SIG_E|T1_SGN_E,
-		T1_SIG_W, T1_SIG_W|T1_SGN_W,
-		T1_SIG_N, T1_SIG_N|T1_SGN_N
-	};
+	/* We strongly rely on (T1_SGN_N == 0x0100) == (T1_SIG_N == 0x0010) << 4 */
+	/* and T1_SIG_E == T1_SIG_N << 1, T1_SIG_W == T1_SIG_N << 2 and T1_SIG_S == T1_SIG_N << 2 */
+	/* and T1_SGN_E == T1_SGN_N << 1, T1_SGN_W == T1_SGN_N << 2 and T1_SGN_S == T1_SGN_N << 2 */
+
+	opj_flag_t flag_N = T1_SIG_N | (T1_SIG_N << (4 * s));
 
 	np[-1] |= T1_SIG_SE;
-	np[0]  |= mod[s];
+	np[0]  |= flag_N << 2;
 	np[1]  |= T1_SIG_SW;
 
-	flagsp[-1] |= mod[s+2];
+	flagsp[-1] |= flag_N << 1;
 	flagsp[0]  |= T1_SIG;
-	flagsp[1]  |= mod[s+4];
+	flagsp[1]  |= flag_N << 3;
 
 	sp[-1] |= T1_SIG_NE;
-	sp[0]  |= mod[s+6];
+	sp[0]  |= flag_N;
 	sp[1]  |= T1_SIG_NW;
 }
 
+static INLINE void opj_t1_updateflagscolflags(opj_flag_t *flagsp, opj_colflag_t *colflagsp, OPJ_UINT32 s, OPJ_UINT32 stride, OPJ_INT32 row)
+{
+	opj_t1_updateflags(flagsp, s, stride);
+	if( row == 0 )
+	{
+			*colflagsp |= (T1_COLFLAG_SIG_ROW_0 <<  (T1_COLFLAG_RBS * row)) |
+						  (T1_COLFLAG_SIG_OTHER_ROW_0 <<  (T1_COLFLAG_RBS * (row+1)));
+			*(colflagsp - 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) |
+							    (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row+1)));
+			*(colflagsp + 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) |
+								(T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row+1)));
+			*(colflagsp - stride - 1) |= (T1_COLFLAG_SIG_OTHER_ROW_3);
+			*(colflagsp - stride) |= (T1_COLFLAG_SIG_OTHER_ROW_3);
+			*(colflagsp - stride + 1) |= (T1_COLFLAG_SIG_OTHER_ROW_3);
+	}
+	else if( row == 3 )
+	{
+			*colflagsp |= (T1_COLFLAG_SIG_ROW_0 <<  (T1_COLFLAG_RBS * row)) |
+						  (T1_COLFLAG_SIG_OTHER_ROW_0 <<  (T1_COLFLAG_RBS * (row-1)));
+			*(colflagsp - 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) |
+							    (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row-1)));
+			*(colflagsp + 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) |
+								(T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS* (row-1)));
+			*(colflagsp + stride - 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0);
+			*(colflagsp + stride) |= (T1_COLFLAG_SIG_OTHER_ROW_0);
+			*(colflagsp + stride + 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0);
+	}
+	else
+	{
+			*(colflagsp - 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) |
+								(T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row-1))) |
+								(T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row+1)));
+			*colflagsp |= (T1_COLFLAG_SIG_ROW_0 <<  (T1_COLFLAG_RBS * row)) |
+						  (T1_COLFLAG_SIG_OTHER_ROW_0 <<  (T1_COLFLAG_RBS * (row-1))) |
+						  (T1_COLFLAG_SIG_OTHER_ROW_0 <<  (T1_COLFLAG_RBS * (row+1)));
+			*(colflagsp + 1) |= (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) |
+								(T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row-1))) |
+								(T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * (row+1)));
+	}
+}
+
 static void opj_t1_enc_sigpass_step(   opj_t1_t *t1,
                                 opj_flag_t *flagsp,
                                 OPJ_INT32 *datap,
-                                OPJ_UINT32 orient,
                                 OPJ_INT32 bpno,
                                 OPJ_INT32 one,
                                 OPJ_INT32 *nmsedec,
@@ -382,7 +421,7 @@ static void opj_t1_enc_sigpass_step(   opj_t1_t *t1,
 	flag = vsc ? (OPJ_UINT32)((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (OPJ_UINT32)(*flagsp);
 	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
 		v = (opj_int_abs(*datap) & one) ? 1 : 0;
-		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(flag, orient));	/* ESSAI */
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, flag));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
 			opj_mqc_bypass_enc(mqc, (OPJ_UINT32)v);
 		} else {
@@ -407,72 +446,89 @@ static void opj_t1_enc_sigpass_step(   opj_t1_t *t1,
 static INLINE void opj_t1_dec_sigpass_step_raw(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t* colflagsp,
                 OPJ_INT32 *datap,
-                OPJ_INT32 orient,
                 OPJ_INT32 oneplushalf,
-                OPJ_INT32 vsc)
+                OPJ_INT32 vsc,
+                OPJ_INT32 row)
 {
         OPJ_INT32 v, flag;
         opj_raw_t *raw = t1->raw;       /* RAW component */
-        OPJ_ARG_NOT_USED(orient);
-       
+
         flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-        if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+        if ((flag & T1_SIG_OTH) && !(*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row)))) {
                         if (opj_raw_decode(raw)) {
                                 v = (OPJ_INT32)opj_raw_decode(raw);    /* ESSAI */
                                 *datap = v ? -oneplushalf : oneplushalf;
-                                opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+                                opj_t1_updateflagscolflags(flagsp, colflagsp, (OPJ_UINT32)v, t1->flags_stride, row);
                         }
+#ifdef CONSISTENCY_CHECK
                 *flagsp |= T1_VISIT;
+#endif
+                *colflagsp |= (T1_COLFLAG_VISIT_ROW_0 << (T1_COLFLAG_RBS * row));
         }
 }      
 
 static INLINE void opj_t1_dec_sigpass_step_mqc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t* colflagsp,
                 OPJ_INT32 *datap,
-                OPJ_INT32 orient,
-                OPJ_INT32 oneplushalf)
+                OPJ_INT32 oneplushalf,
+                OPJ_INT32 row,
+                OPJ_INT32 flags_stride)
 {
         OPJ_INT32 v, flag;
        
         opj_mqc_t *mqc = t1->mqc;       /* MQC component */
-       
-        flag = *flagsp;
-        if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
-                        opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+#ifdef CONSISTENCY_CHECK
+		assert( ((*flagsp & T1_SIG_OTH) && !(*flagsp & (T1_SIG | T1_VISIT))) ==
+				((*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_SIG_OTHER_ROW_0) << (T1_COLFLAG_RBS * row))) ==
+				  (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row))) );
+#endif
+        if( (*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_SIG_OTHER_ROW_0) << (T1_COLFLAG_RBS * row))) ==
+            (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row)) ) {
+                        flag = *flagsp;
+                        opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, (OPJ_UINT32)flag));
                         if (opj_mqc_decode(mqc)) {
                                 opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
                                 v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
                                 *datap = v ? -oneplushalf : oneplushalf;
-                                opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+                                opj_t1_updateflagscolflags(flagsp, colflagsp, (OPJ_UINT32)v, flags_stride, row);
                         }
+#ifdef CONSISTENCY_CHECK
                 *flagsp |= T1_VISIT;
+#endif
+                *colflagsp |= (T1_COLFLAG_VISIT_ROW_0 << (T1_COLFLAG_RBS * row));
         }
 }                               /* VSC and  BYPASS by Antonin */
 
 static INLINE void opj_t1_dec_sigpass_step_mqc_vsc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t* colflagsp,
                 OPJ_INT32 *datap,
-                OPJ_INT32 orient,
                 OPJ_INT32 oneplushalf,
-                OPJ_INT32 vsc)
+                OPJ_INT32 vsc,
+                OPJ_INT32 row)
 {
         OPJ_INT32 v, flag;
        
         opj_mqc_t *mqc = t1->mqc;       /* MQC component */
        
         flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-        if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
-                opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+        if ((flag & T1_SIG_OTH) && !(*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row)))) {
+                opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, (OPJ_UINT32)flag));
                 if (opj_mqc_decode(mqc)) {
                         opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
                         v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
                         *datap = v ? -oneplushalf : oneplushalf;
-                        opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+                        opj_t1_updateflagscolflags(flagsp, colflagsp, (OPJ_UINT32)v, t1->flags_stride, row);
                 }
+#ifdef CONSISTENCY_CHECK
                 *flagsp |= T1_VISIT;
+#endif
+                *colflagsp |= (T1_COLFLAG_VISIT_ROW_0 << (T1_COLFLAG_RBS * row));
         }
 }                               /* VSC and  BYPASS by Antonin */
 
@@ -480,7 +536,6 @@ static INLINE void opj_t1_dec_sigpass_step_mqc_vsc(
 
 static void opj_t1_enc_sigpass(opj_t1_t *t1,
                         OPJ_INT32 bpno,
-                        OPJ_UINT32 orient,
                         OPJ_INT32 *nmsedec,
                         OPJ_BYTE type,
                         OPJ_UINT32 cblksty
@@ -499,7 +554,6 @@ static void opj_t1_enc_sigpass(opj_t1_t *t1,
 						t1,
 						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
 						&t1->data[(j * t1->data_stride) + i],
-						orient,
 						bpno,
 						one,
 						nmsedec,
@@ -513,95 +567,139 @@ static void opj_t1_enc_sigpass(opj_t1_t *t1,
 static void opj_t1_dec_sigpass_raw(
                 opj_t1_t *t1,
                 OPJ_INT32 bpno,
-                OPJ_INT32 orient,
                 OPJ_INT32 cblksty)
 {
         OPJ_INT32 one, half, oneplushalf, vsc;
         OPJ_UINT32 i, j, k; 
+        opj_colflag_t *colflags1 = &t1->colflags[t1->flags_stride + 1];
         one = 1 << bpno;
         half = one >> 1;
         oneplushalf = one | half;
         for (k = 0; k < t1->h; k += 4) {
                 for (i = 0; i < t1->w; ++i) {
+                        opj_colflag_t *colflags2 = colflags1 + i;
                         for (j = k; j < k + 4 && j < t1->h; ++j) {
                                 vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
                                 opj_t1_dec_sigpass_step_raw(
                                                 t1,
                                                 &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                                colflags2,
                                                 &t1->data[(j * t1->w) + i],
-                                                orient,
                                                 oneplushalf,
-                                                vsc);
+                                                vsc,
+                                                j - k);
                         }
                 }
+                colflags1 += t1->flags_stride;
         }
 }                               /* VSC and  BYPASS by Antonin */
 
-static void opj_t1_dec_sigpass_mqc(
+#define opj_t1_dec_sigpass_mqc_internal(t1, bpno, w, h, flags_stride) \
+{ \
+        OPJ_INT32 one, half, oneplushalf; \
+        OPJ_UINT32 i, j, k; \
+        OPJ_INT32 *data1 = t1->data; \
+        opj_flag_t *flags1 = &t1->flags[1]; \
+        opj_colflag_t *colflags1 = &t1->colflags[flags_stride + 1]; \
+        one = 1 << bpno; \
+        half = one >> 1; \
+        oneplushalf = one | half; \
+        for (k = 0; k < (h & ~3u); k += 4) { \
+                for (i = 0; i < w; ++i) { \
+                        OPJ_INT32 *data2 = data1 + i; \
+                        opj_flag_t *flags2 = flags1 + i; \
+                        opj_colflag_t *colflags2 = colflags1 + i; \
+                        if( *colflags2 == 0 ) continue; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, colflags2, data2, oneplushalf, 0, flags_stride); \
+                        data2 += w; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, colflags2, data2, oneplushalf, 1, flags_stride); \
+                        data2 += w; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, colflags2, data2, oneplushalf, 2, flags_stride); \
+                        data2 += w; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, colflags2, data2, oneplushalf, 3, flags_stride); \
+                        data2 += w; \
+                } \
+                data1 += w << 2; \
+                flags1 += flags_stride << 2; \
+                colflags1 += flags_stride; \
+        } \
+        for (i = 0; i < w; ++i) { \
+                OPJ_INT32 *data2 = data1 + i; \
+                opj_flag_t *flags2 = flags1 + i; \
+                opj_colflag_t *colflags2 = colflags1 + i; \
+                for (j = k; j < h; ++j) { \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, colflags2, data2, oneplushalf, j - k, flags_stride); \
+                        data2 += w; \
+                } \
+        } \
+}
+
+static void opj_t1_dec_sigpass_mqc_64x64(
                 opj_t1_t *t1,
-                OPJ_INT32 bpno,
-                OPJ_INT32 orient)
+                OPJ_INT32 bpno)
 {
-        OPJ_INT32 one, half, oneplushalf;
+	opj_t1_dec_sigpass_mqc_internal(t1, bpno, 64, 64, 66);
+}
+
+static void opj_t1_dec_sigpass_mqc_generic(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno)
+{
+	opj_t1_dec_sigpass_mqc_internal(t1, bpno, t1->w, t1->h, t1->flags_stride);
+}
+
+/* VSC and  BYPASS by Antonin */
+static void opj_t1_dec_sigpass_mqc_vsc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno)
+{
+        OPJ_INT32 one, half, oneplushalf, vsc;
         OPJ_UINT32 i, j, k;
         OPJ_INT32 *data1 = t1->data;
         opj_flag_t *flags1 = &t1->flags[1];
+        opj_colflag_t *colflags1 = &t1->colflags[t1->flags_stride + 1];
         one = 1 << bpno;
         half = one >> 1;
         oneplushalf = one | half;
-        for (k = 0; k < (t1->h & ~3u); k += 4) {
+        for (k = 0; k < (t1->h & ~3); k += 4) {
                 for (i = 0; i < t1->w; ++i) {
                         OPJ_INT32 *data2 = data1 + i;
                         opj_flag_t *flags2 = flags1 + i;
+                        opj_colflag_t *colflags2 = colflags1 + i;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        opj_t1_dec_sigpass_step_mqc_vsc(t1, flags2, colflags2, data2, oneplushalf, 0, 0);
                         data2 += t1->w;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        opj_t1_dec_sigpass_step_mqc_vsc(t1, flags2, colflags2, data2, oneplushalf, 0, 1);
                         data2 += t1->w;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        opj_t1_dec_sigpass_step_mqc_vsc(t1, flags2, colflags2, data2, oneplushalf, 0, 2);
                         data2 += t1->w;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        opj_t1_dec_sigpass_step_mqc_vsc(t1, flags2, colflags2, data2, oneplushalf, 1, 3);
                         data2 += t1->w;
                 }
                 data1 += t1->w << 2;
                 flags1 += t1->flags_stride << 2;
+                colflags1 += t1->flags_stride;
         }
         for (i = 0; i < t1->w; ++i) {
-                OPJ_INT32 *data2 = data1 + i;
-                opj_flag_t *flags2 = flags1 + i;
+                opj_colflag_t *colflags2 = colflags1 + i;
                 for (j = k; j < t1->h; ++j) {
-                        flags2 += t1->flags_stride;
-                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
-                        data2 += t1->w;
-                }
-        }
-}                               /* VSC and  BYPASS by Antonin */
-
-static void opj_t1_dec_sigpass_mqc_vsc(
-                opj_t1_t *t1,
-                OPJ_INT32 bpno,
-                OPJ_INT32 orient)
-{
-        OPJ_INT32 one, half, oneplushalf, vsc;
-        OPJ_UINT32 i, j, k;
-        one = 1 << bpno;
-        half = one >> 1;
-        oneplushalf = one | half;
-        for (k = 0; k < t1->h; k += 4) {
-                for (i = 0; i < t1->w; ++i) {
-                        for (j = k; j < k + 4 && j < t1->h; ++j) {
-                                vsc = (j == k + 3 || j == t1->h - 1) ? 1 : 0;
-                                opj_t1_dec_sigpass_step_mqc_vsc(
-                                                t1,
-                                                &t1->flags[((j+1) * t1->flags_stride) + i + 1],
-                                                &t1->data[(j * t1->w) + i],
-                                                orient,
-                                                oneplushalf,
-                                                vsc);
-                        }
+                        vsc = (j == t1->h - 1) ? 1 : 0;
+                        opj_t1_dec_sigpass_step_mqc_vsc(
+                                        t1,
+                                        &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                        colflags2,
+                                        &t1->data[(j * t1->w) + i],
+                                        oneplushalf,
+                                        vsc,
+                                        j - k);
                 }
         }
 }                               /* VSC and  BYPASS by Antonin */
@@ -639,64 +737,81 @@ static void opj_t1_enc_refpass_step(   opj_t1_t *t1,
 static INLINE void opj_t1_dec_refpass_step_raw(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t *colflagsp,
                 OPJ_INT32 *datap,
                 OPJ_INT32 poshalf,
                 OPJ_INT32 neghalf,
-                OPJ_INT32 vsc)
+                OPJ_INT32 row)
 {
-        OPJ_INT32 v, t, flag;
+        OPJ_INT32 v, t;
        
         opj_raw_t *raw = t1->raw;       /* RAW component */
        
-        flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-        if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+        if ((*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row))) ==
+            ((T1_COLFLAG_SIG_ROW_0) << (T1_COLFLAG_RBS * row))) {
                         v = (OPJ_INT32)opj_raw_decode(raw);
                 t = v ? poshalf : neghalf;
                 *datap += *datap < 0 ? -t : t;
-                *flagsp |= T1_REFINE;
+                *colflagsp |= (T1_COLFLAG_REFINE_ROW_0 << (T1_COLFLAG_RBS * row));
         }
 }                               /* VSC and  BYPASS by Antonin  */
 
 static INLINE void opj_t1_dec_refpass_step_mqc(
                 opj_t1_t *t1,
+#ifdef CONSISTENCY_CHECK
                 opj_flag_t *flagsp,
+#else
+                opj_flag_t *flagsp_unused,
+#endif
+                opj_colflag_t *colflagsp,
                 OPJ_INT32 *datap,
                 OPJ_INT32 poshalf,
-                OPJ_INT32 neghalf)
+                OPJ_INT32 neghalf,
+                OPJ_INT32 row)
 {
-        OPJ_INT32 v, t, flag;
+        OPJ_INT32 v, t;
        
         opj_mqc_t *mqc = t1->mqc;       /* MQC component */
-       
-        flag = *flagsp;
-        if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
-                opj_mqc_setcurctx(mqc, opj_t1_getctxno_mag((OPJ_UINT32)flag));      /* ESSAI */
+#ifdef CONSISTENCY_CHECK
+		assert( ((*flagsp & (T1_SIG | T1_VISIT)) == T1_SIG) == 
+				((*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row))) == ((T1_COLFLAG_SIG_ROW_0) << (T1_COLFLAG_RBS * row))) );
+#endif
+        if ((*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row))) ==
+            ((T1_COLFLAG_SIG_ROW_0) << (T1_COLFLAG_RBS * row))) {
+                OPJ_UINT32 tmp1 = (*colflagsp & (T1_COLFLAG_SIG_OTHER_ROW_0 << (T1_COLFLAG_RBS * row))) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
+                OPJ_UINT32 tmp2 = (*colflagsp & (T1_COLFLAG_REFINE_ROW_0 << (T1_COLFLAG_RBS * row))) ? T1_CTXNO_MAG + 2 : tmp1;
+                opj_mqc_setcurctx(mqc, tmp2);      /* ESSAI */
                         v = opj_mqc_decode(mqc);
                 t = v ? poshalf : neghalf;
                 *datap += *datap < 0 ? -t : t;
-                *flagsp |= T1_REFINE;
+                *colflagsp |= (T1_COLFLAG_REFINE_ROW_0 << (T1_COLFLAG_RBS * row));
                 }
 }                               /* VSC and  BYPASS by Antonin  */
 
 static INLINE void opj_t1_dec_refpass_step_mqc_vsc(
                 opj_t1_t *t1,
                 opj_flag_t *flagsp,
+                opj_colflag_t *colflagsp,
                 OPJ_INT32 *datap,
                 OPJ_INT32 poshalf,
                 OPJ_INT32 neghalf,
-                OPJ_INT32 vsc)
+                OPJ_INT32 vsc,
+                OPJ_INT32 row)
 {
         OPJ_INT32 v, t, flag;
        
         opj_mqc_t *mqc = t1->mqc;       /* MQC component */
        
-        flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-        if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
-                opj_mqc_setcurctx(mqc, opj_t1_getctxno_mag((OPJ_UINT32)flag));      /* ESSAI */
+        if ((*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row))) ==
+                ((T1_COLFLAG_SIG_ROW_0) << (T1_COLFLAG_RBS * row))) {
+                OPJ_INT32 flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+                OPJ_UINT32 tmp1 = (flag & T1_SIG_OTH) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
+                OPJ_UINT32 tmp2 = (*colflagsp & (T1_COLFLAG_REFINE_ROW_0 << (T1_COLFLAG_RBS * row))) ? T1_CTXNO_MAG + 2 : tmp1;
+                opj_mqc_setcurctx(mqc, tmp2);      /* ESSAI */
                 v = opj_mqc_decode(mqc);
                 t = v ? poshalf : neghalf;
                 *datap += *datap < 0 ? -t : t;
-                *flagsp |= T1_REFINE;
+                *colflagsp |= (T1_COLFLAG_REFINE_ROW_0 << (T1_COLFLAG_RBS * row));
         }
 }                               /* VSC and  BYPASS by Antonin  */
 
@@ -739,89 +854,134 @@ static void opj_t1_dec_refpass_raw(
         OPJ_INT32 one, poshalf, neghalf;
         OPJ_UINT32 i, j, k;
         OPJ_INT32 vsc;
+        opj_colflag_t *colflags1 = &t1->colflags[t1->flags_stride + 1];
         one = 1 << bpno;
         poshalf = one >> 1;
         neghalf = bpno > 0 ? -poshalf : -1;
         for (k = 0; k < t1->h; k += 4) {
                 for (i = 0; i < t1->w; ++i) {
+                        opj_colflag_t *colflags2 = colflags1 + i;
                         for (j = k; j < k + 4 && j < t1->h; ++j) {
-                                vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
                                 opj_t1_dec_refpass_step_raw(
                                                 t1,
                                                 &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                                colflags2,
                                                 &t1->data[(j * t1->w) + i],
                                                 poshalf,
-                                                neghalf,
-                                                vsc);
+                                                neghalf, j - k);
                         }
                 }
+                colflags1 += t1->flags_stride;
         }
 }                               /* VSC and  BYPASS by Antonin */
 
-static void opj_t1_dec_refpass_mqc(
+#define opj_t1_dec_refpass_mqc_internal(t1, bpno, w, h, flags_stride) \
+{ \
+        OPJ_INT32 one, poshalf, neghalf; \
+        OPJ_UINT32 i, j, k; \
+        OPJ_INT32 *data1 = t1->data; \
+        opj_flag_t *flags1 = &t1->flags[1]; \
+        opj_colflag_t *colflags1 = &t1->colflags[flags_stride + 1]; \
+        one = 1 << bpno; \
+        poshalf = one >> 1; \
+        neghalf = bpno > 0 ? -poshalf : -1; \
+        for (k = 0; k < (h & ~3u); k += 4) { \
+                for (i = 0; i < w; ++i) { \
+                        OPJ_INT32 *data2 = data1 + i; \
+                        opj_flag_t *flags2 = flags1 + i; \
+                        opj_colflag_t *colflags2 = colflags1 + i; \
+                        if( *colflags2 == 0 ) continue; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, colflags2, data2, poshalf, neghalf, 0); \
+                        data2 += w; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, colflags2, data2, poshalf, neghalf, 1); \
+                        data2 += w; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, colflags2, data2, poshalf, neghalf, 2); \
+                        data2 += w; \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, colflags2, data2, poshalf, neghalf, 3); \
+                        data2 += w; \
+                } \
+                data1 += w << 2; \
+                flags1 += flags_stride << 2; \
+                colflags1 += flags_stride; \
+        } \
+        for (i = 0; i < w; ++i) { \
+                OPJ_INT32 *data2 = data1 + i; \
+                opj_flag_t *flags2 = flags1 + i; \
+                opj_colflag_t *colflags2 = colflags1 + i; \
+                for (j = k; j < h; ++j) { \
+                        flags2 += flags_stride; \
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, colflags2, data2, poshalf, neghalf, j - k); \
+                        data2 += w; \
+                } \
+        } \
+}
+
+static void opj_t1_dec_refpass_mqc_64x64(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno)
+{
+	opj_t1_dec_refpass_mqc_internal(t1, bpno, 64, 64, 66);
+}
+
+static void opj_t1_dec_refpass_mqc_generic(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno)
+{
+	opj_t1_dec_refpass_mqc_internal(t1, bpno, t1->w, t1->h, t1->flags_stride);
+}
+
+/* VSC and  BYPASS by Antonin */
+static void opj_t1_dec_refpass_mqc_vsc(
                 opj_t1_t *t1,
                 OPJ_INT32 bpno)
 {
         OPJ_INT32 one, poshalf, neghalf;
         OPJ_UINT32 i, j, k;
+        OPJ_INT32 vsc;
         OPJ_INT32 *data1 = t1->data;
         opj_flag_t *flags1 = &t1->flags[1];
+        opj_colflag_t *colflags1 = &t1->colflags[t1->flags_stride + 1];
         one = 1 << bpno;
         poshalf = one >> 1;
         neghalf = bpno > 0 ? -poshalf : -1;
-        for (k = 0; k < (t1->h & ~3u); k += 4) {
+        for (k = 0; k < (t1->h & ~3); k += 4) {
                 for (i = 0; i < t1->w; ++i) {
                         OPJ_INT32 *data2 = data1 + i;
                         opj_flag_t *flags2 = flags1 + i;
+                        opj_colflag_t *colflags2 = colflags1 + i;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        opj_t1_dec_refpass_step_mqc_vsc(t1, flags2, colflags2, data2, poshalf, neghalf, 0, 0);
                         data2 += t1->w;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        opj_t1_dec_refpass_step_mqc_vsc(t1, flags2, colflags2, data2, poshalf, neghalf, 0, 1);
                         data2 += t1->w;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        opj_t1_dec_refpass_step_mqc_vsc(t1, flags2, colflags2, data2, poshalf, neghalf, 0, 2);
                         data2 += t1->w;
                         flags2 += t1->flags_stride;
-                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        opj_t1_dec_refpass_step_mqc_vsc(t1, flags2, colflags2, data2, poshalf, neghalf, 1, 3);
                         data2 += t1->w;
                 }
                 data1 += t1->w << 2;
                 flags1 += t1->flags_stride << 2;
+                colflags1 += t1->flags_stride;
         }
         for (i = 0; i < t1->w; ++i) {
-                OPJ_INT32 *data2 = data1 + i;
-                opj_flag_t *flags2 = flags1 + i;
+                opj_colflag_t *colflags2 = colflags1 + i;
                 for (j = k; j < t1->h; ++j) {
-                        flags2 += t1->flags_stride;
-                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
-                        data2 += t1->w;
-                }
-        }
-}                               /* VSC and  BYPASS by Antonin */
-
-static void opj_t1_dec_refpass_mqc_vsc(
-                opj_t1_t *t1,
-                OPJ_INT32 bpno)
-{
-        OPJ_INT32 one, poshalf, neghalf;
-        OPJ_UINT32 i, j, k;
-        OPJ_INT32 vsc;
-        one = 1 << bpno;
-        poshalf = one >> 1;
-        neghalf = bpno > 0 ? -poshalf : -1;
-        for (k = 0; k < t1->h; k += 4) {
-                for (i = 0; i < t1->w; ++i) {
-                        for (j = k; j < k + 4 && j < t1->h; ++j) {
-                                vsc = ((j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-                                opj_t1_dec_refpass_step_mqc_vsc(
-                                                t1,
-                                                &t1->flags[((j+1) * t1->flags_stride) + i + 1],
-                                                &t1->data[(j * t1->w) + i],
-                                                poshalf,
-                                                neghalf,
-                                                vsc);
-                        }
+                        vsc = (j == t1->h - 1) ? 1 : 0;
+                        opj_t1_dec_refpass_step_mqc_vsc(
+                                        t1,
+                                        &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                        colflags2,
+                                        &t1->data[(j * t1->w) + i],
+                                        poshalf, neghalf,
+                                        vsc,
+                                        j - k);
                 }
         }
 }                               /* VSC and  BYPASS by Antonin */
@@ -831,7 +991,6 @@ static void opj_t1_enc_clnpass_step(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
 		OPJ_INT32 *datap,
-		OPJ_UINT32 orient,
 		OPJ_INT32 bpno,
 		OPJ_INT32 one,
 		OPJ_INT32 *nmsedec,
@@ -848,7 +1007,7 @@ static void opj_t1_enc_clnpass_step(
 		goto LABEL_PARTIAL;
 	}
 	if (!(*flagsp & (T1_SIG | T1_VISIT))) {
-		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(flag, orient));
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, flag));
 		v = (opj_int_abs(*datap) & one) ? 1 : 0;
 		opj_mqc_encode(mqc, (OPJ_UINT32)v);
 		if (v) {
@@ -866,55 +1025,90 @@ static void opj_t1_enc_clnpass_step(
 static void opj_t1_dec_clnpass_step_partial(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
+		opj_colflag_t *colflagsp,
 		OPJ_INT32 *datap,
-		OPJ_INT32 orient,
-		OPJ_INT32 oneplushalf)
+		OPJ_INT32 oneplushalf,
+		OPJ_INT32 row)
 {
 	OPJ_INT32 v, flag;
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
-	OPJ_ARG_NOT_USED(orient);
-	
 	flag = *flagsp;
 	opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
 	v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
 	*datap = v ? -oneplushalf : oneplushalf;
-	opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+	opj_t1_updateflagscolflags(flagsp, colflagsp, (OPJ_UINT32)v, t1->flags_stride, row);
+#ifdef CONSISTENCY_CHECK
 	*flagsp &= ~T1_VISIT;
+#endif
 }				/* VSC and  BYPASS by Antonin */
 
 static void opj_t1_dec_clnpass_step(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
+		opj_colflag_t *colflagsp,
 		OPJ_INT32 *datap,
-		OPJ_INT32 orient,
-		OPJ_INT32 oneplushalf)
+		OPJ_INT32 oneplushalf,
+		OPJ_INT32 row)
 {
 	OPJ_INT32 v, flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	flag = *flagsp;
-	if (!(flag & (T1_SIG | T1_VISIT))) {
-		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+#ifdef CONSISTENCY_CHECK
+	assert( (!(*flagsp & (T1_SIG | T1_VISIT))) == (!(*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (4*row)))) );
+#endif
+	if (!(*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (4*row)))) {
+		flag = *flagsp;
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, (OPJ_UINT32)flag));
 		if (opj_mqc_decode(mqc)) {
 			opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
 			v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
 			*datap = v ? -oneplushalf : oneplushalf;
-			opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+			opj_t1_updateflagscolflags(flagsp, colflagsp, (OPJ_UINT32)v, t1->flags_stride, row);
 		}
 	}
+#ifdef CONSISTENCY_CHECK
 	*flagsp &= ~T1_VISIT;
+#endif
 }				/* VSC and  BYPASS by Antonin */
 
+static void opj_t1_dec_clnpass_step_only_if_flag_not_sig_visit(
+        opj_t1_t *t1,
+        opj_flag_t *flagsp,
+        opj_colflag_t *colflagsp,
+        OPJ_INT32 *datap,
+        OPJ_INT32 oneplushalf,
+        OPJ_INT32 row,
+        OPJ_INT32 flags_stride)
+{
+    OPJ_INT32 v;
+    OPJ_INT32 flag;
+
+    opj_mqc_t *mqc = t1->mqc;   /* MQC component */
+
+    flag = *flagsp;
+    /*if (!(flag & (T1_SIG | T1_VISIT)))*/
+    {
+        opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, (OPJ_UINT32)flag));
+        if (opj_mqc_decode(mqc)) {
+            opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
+            v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
+            *datap = v ? -oneplushalf : oneplushalf;
+            opj_t1_updateflagscolflags(flagsp, colflagsp, v, flags_stride, row);
+        }
+    }
+    /*flagsp &= ~T1_VISIT;*/
+}
+
 static void opj_t1_dec_clnpass_step_vsc(
 		opj_t1_t *t1,
 		opj_flag_t *flagsp,
+        opj_colflag_t *colflagsp,
 		OPJ_INT32 *datap,
-		OPJ_INT32 orient,
 		OPJ_INT32 oneplushalf,
 		OPJ_INT32 partial,
-		OPJ_INT32 vsc)
+		OPJ_INT32 vsc,
+        OPJ_INT32 row)
 {
 	OPJ_INT32 v, flag;
 	
@@ -924,23 +1118,24 @@ static void opj_t1_dec_clnpass_step_vsc(
 	if (partial) {
 		goto LABEL_PARTIAL;
 	}
-	if (!(flag & (T1_SIG | T1_VISIT))) {
-		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+	if (!(*colflagsp & ((T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0) << (T1_COLFLAG_RBS * row)))) {
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(mqc, (OPJ_UINT32)flag));
 		if (opj_mqc_decode(mqc)) {
 LABEL_PARTIAL:
 			opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
 			v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
 			*datap = v ? -oneplushalf : oneplushalf;
-			opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+			opj_t1_updateflagscolflags(flagsp, colflagsp, v, t1->flags_stride, row);
 		}
 	}
+#ifdef CONSISTENCY_CHECK
 	*flagsp &= ~T1_VISIT;
+#endif
 }
 
 static void opj_t1_enc_clnpass(
 		opj_t1_t *t1,
 		OPJ_INT32 bpno,
-		OPJ_UINT32 orient,
 		OPJ_INT32 *nmsedec,
 		OPJ_UINT32 cblksty)
 {
@@ -992,7 +1187,6 @@ static void opj_t1_enc_clnpass(
 						t1,
 						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
 						&t1->data[(j * t1->data_stride) + i],
-						orient,
 						bpno,
 						one,
 						nmsedec,
@@ -1003,130 +1197,186 @@ static void opj_t1_enc_clnpass(
 	}
 }
 
-static void opj_t1_dec_clnpass(
+#define MACRO_t1_flags_internal(x,y,flags_stride) t1->flags[((x)*(flags_stride))+(y)]
+
+#define opj_t1_dec_clnpass_internal(consistency_check, t1, bpno, cblksty, w, h, flags_stride) \
+{ \
+	OPJ_INT32 one, half, oneplushalf, agg, runlen, vsc; \
+    OPJ_UINT32 i, j, k; \
+	OPJ_INT32 segsym = cblksty & J2K_CCP_CBLKSTY_SEGSYM; \
+	 \
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */ \
+	 \
+	one = 1 << bpno; \
+	half = one >> 1; \
+	oneplushalf = one | half; \
+	if (cblksty & J2K_CCP_CBLKSTY_VSC) { \
+	opj_colflag_t *colflags1 = &t1->colflags[flags_stride + 1]; \
+	for (k = 0; k < h; k += 4) { \
+		for (i = 0; i < w; ++i) { \
+			opj_colflag_t *colflags2 = colflags1 + i; \
+			if (k + 3 < h) { \
+					agg = !((*colflags2 & (T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_SIG_OTHER_ROW_0 | \
+						                   T1_COLFLAG_SIG_ROW_1 | T1_COLFLAG_VISIT_ROW_1 | T1_COLFLAG_SIG_OTHER_ROW_1 | \
+						                   T1_COLFLAG_SIG_ROW_2 | T1_COLFLAG_VISIT_ROW_2 | T1_COLFLAG_SIG_OTHER_ROW_2 | \
+						                   T1_COLFLAG_SIG_ROW_3 | T1_COLFLAG_VISIT_ROW_3)) || \
+						  ((MACRO_t1_flags_internal(1 + k + 3,1 + i,flags_stride) \
+						   & ((~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG_OTH)))); \
+				} else { \
+				agg = 0; \
+			} \
+			if (agg) { \
+				opj_mqc_setcurctx(mqc, T1_CTXNO_AGG); \
+				if (!opj_mqc_decode(mqc)) { \
+					continue; \
+				} \
+				opj_mqc_setcurctx(mqc, T1_CTXNO_UNI); \
+				runlen = opj_mqc_decode(mqc); \
+				runlen = (runlen << 1) | opj_mqc_decode(mqc); \
+			} else { \
+				runlen = 0; \
+			} \
+			for (j = k + (OPJ_UINT32)runlen; j < k + 4 && j < h; ++j) { \
+					vsc = (j == k + 3 || j == h - 1) ? 1 : 0; \
+					opj_t1_dec_clnpass_step_vsc( \
+						t1, \
+						&t1->flags[((j+1) * flags_stride) + i + 1], \
+						colflags2, \
+						&t1->data[(j * w) + i], \
+						oneplushalf, \
+						agg && (j == k + (OPJ_UINT32)runlen), \
+						vsc, j - k); \
+			} \
+			*colflags2 &= ~(T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_VISIT_ROW_1 | T1_COLFLAG_VISIT_ROW_2 | T1_COLFLAG_VISIT_ROW_3); \
+		} \
+		colflags1 += flags_stride; \
+	} \
+	} else { \
+		OPJ_INT32 *data1 = t1->data; \
+		opj_flag_t *flags1 = &t1->flags[1]; \
+		opj_colflag_t *colflags1 = &t1->colflags[flags_stride + 1]; \
+		for (k = 0; k < (h & ~3u); k += 4) { \
+			for (i = 0; i < w; ++i) { \
+				OPJ_INT32 *data2 = data1 + i; \
+				opj_flag_t *flags2 = flags1 + i; \
+				opj_colflag_t *colflags2 = colflags1 + i; \
+				opj_colflag_t colflags = *colflags2; \
+				agg = !(colflags & (T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_SIG_OTHER_ROW_0 | \
+									 T1_COLFLAG_SIG_ROW_1 | T1_COLFLAG_VISIT_ROW_1 | T1_COLFLAG_SIG_OTHER_ROW_1 | \
+								 	 T1_COLFLAG_SIG_ROW_2 | T1_COLFLAG_VISIT_ROW_2 | T1_COLFLAG_SIG_OTHER_ROW_2 | \
+									 T1_COLFLAG_SIG_ROW_3 | T1_COLFLAG_VISIT_ROW_3 | T1_COLFLAG_SIG_OTHER_ROW_3)); \
+				if( consistency_check ) { \
+					assert( agg == !((MACRO_t1_flags_internal(1 + k, 1 + i,flags_stride) | \
+									  MACRO_t1_flags_internal(1 + k + 1, 1 + i,flags_stride) | \
+									  MACRO_t1_flags_internal(1 + k + 2, 1 + i,flags_stride) | \
+									  MACRO_t1_flags_internal(1 + k + 3, 1 + i,flags_stride)) & (T1_SIG | T1_VISIT | T1_SIG_OTH)) ); \
+				} \
+				if (agg) { \
+					opj_mqc_setcurctx(mqc, T1_CTXNO_AGG); \
+					if (!opj_mqc_decode(mqc)) { \
+						continue; \
+					} \
+					opj_mqc_setcurctx(mqc, T1_CTXNO_UNI); \
+					runlen = opj_mqc_decode(mqc); \
+					runlen = (runlen << 1) | opj_mqc_decode(mqc); \
+					flags2 += (OPJ_UINT32)runlen * flags_stride; \
+					data2 += (OPJ_UINT32)runlen * w; \
+					for (j = (OPJ_UINT32)runlen; j < 4; ++j) { \
+						flags2 += flags_stride; \
+						if (j == (OPJ_UINT32)runlen) { \
+							opj_t1_dec_clnpass_step_partial(t1, flags2, colflags2, data2, oneplushalf, j); \
+						} else { \
+							opj_t1_dec_clnpass_step(t1, flags2, colflags2, data2, oneplushalf, j); \
+						} \
+						data2 += w; \
+					} \
+				} else { \
+					flags2 += flags_stride; \
+					if( consistency_check ) { assert( (!(colflags & (T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0))) == (!(*flags2 & (T1_SIG | T1_VISIT))) ); } \
+					if (!(colflags & (T1_COLFLAG_SIG_ROW_0 | T1_COLFLAG_VISIT_ROW_0))) {\
+						opj_t1_dec_clnpass_step_only_if_flag_not_sig_visit(t1, flags2, colflags2, data2, oneplushalf, 0, flags_stride); \
+					} \
+					if( consistency_check ) *flags2 &= ~T1_VISIT; \
+					data2 += w; \
+					flags2 += flags_stride; \
+					if( consistency_check ) { assert( (!(colflags & (T1_COLFLAG_SIG_ROW_1 | T1_COLFLAG_VISIT_ROW_1))) == (!(*flags2 & (T1_SIG | T1_VISIT))) ); } \
+					if (!(colflags & (T1_COLFLAG_SIG_ROW_1 | T1_COLFLAG_VISIT_ROW_1))) {\
+						opj_t1_dec_clnpass_step_only_if_flag_not_sig_visit(t1, flags2, colflags2, data2, oneplushalf, 1, flags_stride); \
+					} \
+					if( consistency_check ) *flags2 &= ~T1_VISIT; \
+					data2 += w; \
+					flags2 += flags_stride; \
+					if( consistency_check ) { assert( (!(colflags & (T1_COLFLAG_SIG_ROW_2 | T1_COLFLAG_VISIT_ROW_2))) == (!(*flags2 & (T1_SIG | T1_VISIT))) ); } \
+					if (!(colflags & (T1_COLFLAG_SIG_ROW_2 | T1_COLFLAG_VISIT_ROW_2))) {\
+						opj_t1_dec_clnpass_step_only_if_flag_not_sig_visit(t1, flags2, colflags2, data2, oneplushalf, 2, flags_stride); \
+					} \
+					if( consistency_check ) *flags2 &= ~T1_VISIT; \
+					data2 += w; \
+					flags2 += flags_stride; \
+					if( consistency_check ) { assert( (!(colflags & (T1_COLFLAG_SIG_ROW_3 | T1_COLFLAG_VISIT_ROW_3))) == (!(*flags2 & (T1_SIG | T1_VISIT))) ); } \
+					if (!(colflags & (T1_COLFLAG_SIG_ROW_3 | T1_COLFLAG_VISIT_ROW_3))) {\
+						opj_t1_dec_clnpass_step_only_if_flag_not_sig_visit(t1, flags2, colflags2, data2, oneplushalf, 3, flags_stride); \
+					} \
+					if( consistency_check ) *flags2 &= ~T1_VISIT; \
+					data2 += w; \
+				} \
+				*colflags2 &= ~(T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_VISIT_ROW_1 | T1_COLFLAG_VISIT_ROW_2 | T1_COLFLAG_VISIT_ROW_3); \
+			} \
+			data1 += w << 2; \
+			flags1 += flags_stride << 2; \
+			colflags1 += flags_stride; \
+		} \
+		for (i = 0; i < w; ++i) { \
+			OPJ_INT32 *data2 = data1 + i; \
+			opj_flag_t *flags2 = flags1 + i; \
+			opj_colflag_t *colflags2 = colflags1 + i; \
+			for (j = k; j < h; ++j) { \
+				flags2 += flags_stride; \
+				opj_t1_dec_clnpass_step(t1, flags2, colflags2, data2, oneplushalf, j - k); \
+				data2 += w; \
+			} \
+			*colflags2 &= ~(T1_COLFLAG_VISIT_ROW_0 | T1_COLFLAG_VISIT_ROW_1 | T1_COLFLAG_VISIT_ROW_2 | T1_COLFLAG_VISIT_ROW_3); \
+		} \
+	} \
+ \
+	if (segsym) { \
+		OPJ_INT32 v = 0; \
+		opj_mqc_setcurctx(mqc, T1_CTXNO_UNI); \
+		v = opj_mqc_decode(mqc); \
+		v = (v << 1) | opj_mqc_decode(mqc); \
+		v = (v << 1) | opj_mqc_decode(mqc); \
+		v = (v << 1) | opj_mqc_decode(mqc); \
+		/* \
+		if (v!=0xa) { \
+			opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v); \
+		} \
+		*/ \
+	} \
+}				/* VSC and  BYPASS by Antonin */
+
+static void opj_t1_dec_clnpass_64x64(
 		opj_t1_t *t1,
 		OPJ_INT32 bpno,
-		OPJ_INT32 orient,
 		OPJ_INT32 cblksty)
 {
-	OPJ_INT32 one, half, oneplushalf, agg, runlen, vsc;
-    OPJ_UINT32 i, j, k;
-	OPJ_INT32 segsym = cblksty & J2K_CCP_CBLKSTY_SEGSYM;
-	
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	one = 1 << bpno;
-	half = one >> 1;
-	oneplushalf = one | half;
-	if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-	for (k = 0; k < t1->h; k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			if (k + 3 < t1->h) {
-					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| (MACRO_t1_flags(1 + k + 3,1 + i) 
-						& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
-				} else {
-				agg = 0;
-			}
-			if (agg) {
-				opj_mqc_setcurctx(mqc, T1_CTXNO_AGG);
-				if (!opj_mqc_decode(mqc)) {
-					continue;
-				}
-				opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
-				runlen = opj_mqc_decode(mqc);
-				runlen = (runlen << 1) | opj_mqc_decode(mqc);
-			} else {
-				runlen = 0;
-			}
-			for (j = k + (OPJ_UINT32)runlen; j < k + 4 && j < t1->h; ++j) {
-					vsc = (j == k + 3 || j == t1->h - 1) ? 1 : 0;
-					opj_t1_dec_clnpass_step_vsc(
-						t1,
-						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
-						&t1->data[(j * t1->w) + i],
-						orient,
-						oneplushalf,
-						agg && (j == k + (OPJ_UINT32)runlen),
-						vsc);
-			}
-		}
-	}
-	} else {
-		OPJ_INT32 *data1 = t1->data;
-		opj_flag_t *flags1 = &t1->flags[1];
-		for (k = 0; k < (t1->h & ~3u); k += 4) {
-			for (i = 0; i < t1->w; ++i) {
-				OPJ_INT32 *data2 = data1 + i;
-				opj_flag_t *flags2 = flags1 + i;
-				agg = !((MACRO_t1_flags(1 + k, 1 + i) |
-							MACRO_t1_flags(1 + k + 1, 1 + i) |
-							MACRO_t1_flags(1 + k + 2, 1 + i) |
-							MACRO_t1_flags(1 + k + 3, 1 + i)) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
-				if (agg) {
-					opj_mqc_setcurctx(mqc, T1_CTXNO_AGG);
-					if (!opj_mqc_decode(mqc)) {
-						continue;
-					}
-					opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
-					runlen = opj_mqc_decode(mqc);
-					runlen = (runlen << 1) | opj_mqc_decode(mqc);
-					flags2 += (OPJ_UINT32)runlen * t1->flags_stride;
-					data2 += (OPJ_UINT32)runlen * t1->w;
-					for (j = (OPJ_UINT32)runlen; j < 4 && j < t1->h; ++j) {
-						flags2 += t1->flags_stride;
-						if (agg && (j == (OPJ_UINT32)runlen)) {
-							opj_t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
-						} else {
-							opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
-						}
-						data2 += t1->w;
-					}
-				} else {
-					flags2 += t1->flags_stride;
-					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
-					data2 += t1->w;
-					flags2 += t1->flags_stride;
-					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
-					data2 += t1->w;
-					flags2 += t1->flags_stride;
-					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
-					data2 += t1->w;
-					flags2 += t1->flags_stride;
-					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
-					data2 += t1->w;
-				}
-			}
-			data1 += t1->w << 2;
-			flags1 += t1->flags_stride << 2;
-		}
-		for (i = 0; i < t1->w; ++i) {
-			OPJ_INT32 *data2 = data1 + i;
-			opj_flag_t *flags2 = flags1 + i;
-			for (j = k; j < t1->h; ++j) {
-				flags2 += t1->flags_stride;
-				opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
-				data2 += t1->w;
-			}
-		}
-	}
+#ifdef CONSISTENCY_CHECK
+	opj_t1_dec_clnpass_internal(OPJ_TRUE, t1, bpno, cblksty, 64, 64, 66);
+#else
+	opj_t1_dec_clnpass_internal(OPJ_FALSE, t1, bpno, cblksty, 64, 64, 66);
+#endif
+}
 
-	if (segsym) {
-		OPJ_INT32 v = 0;
-		opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
-		v = opj_mqc_decode(mqc);
-		v = (v << 1) | opj_mqc_decode(mqc);
-		v = (v << 1) | opj_mqc_decode(mqc);
-		v = (v << 1) | opj_mqc_decode(mqc);
-		/*
-		if (v!=0xa) {
-			opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v);
-		} 
-		*/
-	}
-}				/* VSC and  BYPASS by Antonin */
+static void opj_t1_dec_clnpass_generic(
+		opj_t1_t *t1,
+		OPJ_INT32 bpno,
+		OPJ_INT32 cblksty)
+{
+#ifdef CONSISTENCY_CHECK
+	opj_t1_dec_clnpass_internal(OPJ_TRUE, t1, bpno, cblksty, t1->w, t1->h, t1->flags_stride);
+#else
+	opj_t1_dec_clnpass_internal(OPJ_FALSE, t1, bpno, cblksty, t1->w, t1->h, t1->flags_stride);
+#endif
+}
 
 
 /** mod fixed_quality */
@@ -1198,6 +1448,21 @@ static OPJ_BOOL opj_t1_allocate_buffers(
 		t1->flagssize=flagssize;
 	}
 	memset(t1->flags,0,flagssize * sizeof(opj_flag_t));
+	
+	if (!t1->encoder) {
+		OPJ_UINT32 colflags_size=t1->flags_stride * ((h+3) / 4 + 2);
+
+		if(colflags_size > t1->colflags_size){
+			opj_aligned_free(t1->colflags);
+			t1->colflags = (opj_colflag_t*) opj_aligned_malloc(colflags_size * sizeof(opj_colflag_t));
+			if(!t1->colflags){
+				/* FIXME event manager error callback */
+				return OPJ_FALSE;
+			}
+			t1->colflags_size=colflags_size;
+		}
+		memset(t1->colflags,0,colflags_size * sizeof(opj_colflag_t));
+	}
 
 	t1->w=w;
 	t1->h=h;
@@ -1268,6 +1533,10 @@ void opj_t1_destroy(opj_t1_t *p_t1)
 		p_t1->flags = 00;
 	}
 
+	if (p_t1->colflags) {
+		opj_aligned_free(p_t1->colflags);
+		p_t1->colflags = 00;
+	}
 	opj_free(p_t1);
 }
 
@@ -1335,7 +1604,18 @@ OPJ_BOOL opj_t1_decode_cblks(   opj_t1_t* t1,
 					if (tccp->qmfbid == 1) {
                         OPJ_INT32* restrict tiledp = &tilec->data[(OPJ_UINT32)y * tile_w + (OPJ_UINT32)x];
 						for (j = 0; j < cblk_h; ++j) {
-							for (i = 0; i < cblk_w; ++i) {
+							i = 0;
+							for (; i < (cblk_w & ~3); i += 4) {
+								OPJ_INT32 tmp0 = datap[(j * cblk_w) + i];
+								OPJ_INT32 tmp1 = datap[(j * cblk_w) + i+1];
+								OPJ_INT32 tmp2 = datap[(j * cblk_w) + i+2];
+								OPJ_INT32 tmp3 = datap[(j * cblk_w) + i+3];
+								((OPJ_INT32*)tiledp)[(j * tile_w) + i] = tmp0/2;
+								((OPJ_INT32*)tiledp)[(j * tile_w) + i+1] = tmp1/2;
+								((OPJ_INT32*)tiledp)[(j * tile_w) + i+2] = tmp2/2;
+								((OPJ_INT32*)tiledp)[(j * tile_w) + i+3] = tmp3/2;
+							}
+							for (; i < cblk_w; ++i) {
 								OPJ_INT32 tmp = datap[(j * cblk_w) + i];
 								((OPJ_INT32*)tiledp)[(j * tile_w) + i] = tmp/2;
 							}
@@ -1369,12 +1649,14 @@ static OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1,
 {
 	opj_raw_t *raw = t1->raw;	/* RAW component */
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-
+	
 	OPJ_INT32 bpno_plus_one;
 	OPJ_UINT32 passtype;
 	OPJ_UINT32 segno, passno;
 	OPJ_BYTE type = T1_TYPE_MQ; /* BYPASS mode */
 
+	mqc->lut_ctxno_zc_orient = lut_ctxno_zc + orient * 256;
+
 	if(!opj_t1_allocate_buffers(
 				t1,
 				(OPJ_UINT32)(cblk->x1 - cblk->x0),
@@ -1408,45 +1690,91 @@ static OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1,
             }
 		}
 
-		for (passno = 0; (passno < seg->real_num_passes) && (bpno_plus_one >= 1); ++passno) {
-            switch (passtype) {
-                case 0:
-                    if (type == T1_TYPE_RAW) {
-                        opj_t1_dec_sigpass_raw(t1, bpno_plus_one, (OPJ_INT32)orient, (OPJ_INT32)cblksty);
-                    } else {
-                        if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-                            opj_t1_dec_sigpass_mqc_vsc(t1, bpno_plus_one, (OPJ_INT32)orient);
-                        } else {
-                            opj_t1_dec_sigpass_mqc(t1, bpno_plus_one, (OPJ_INT32)orient);
-                        }
-                    }
-                    break;
-                case 1:
-                    if (type == T1_TYPE_RAW) {
-                            opj_t1_dec_refpass_raw(t1, bpno_plus_one, (OPJ_INT32)cblksty);
-                    } else {
-                        if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-                            opj_t1_dec_refpass_mqc_vsc(t1, bpno_plus_one);
-                        } else {
-                            opj_t1_dec_refpass_mqc(t1, bpno_plus_one);
-                        }
-                    }
-                    break;
-                case 2:
-                    opj_t1_dec_clnpass(t1, bpno_plus_one, (OPJ_INT32)orient, (OPJ_INT32)cblksty);
-                    break;
-            }
-
-			if ((cblksty & J2K_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
-				opj_mqc_resetstates(mqc);
-				opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
-				opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
-				opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
-			}
-			if (++passtype == 3) {
-				passtype = 0;
-				bpno_plus_one--;
-			}
+		if( t1->w == 64 && t1->h == 64 )
+		{
+		  for (passno = 0; (passno < seg->real_num_passes) && (bpno_plus_one >= 1); ++passno) {
+			  switch (passtype) {
+				  case 0:
+					  if (type == T1_TYPE_RAW) {
+						  opj_t1_dec_sigpass_raw(t1, bpno_plus_one, (OPJ_INT32)cblksty);
+					  } else {
+						  if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+							  opj_t1_dec_sigpass_mqc_vsc(t1, bpno_plus_one);
+						  } else {
+							  opj_t1_dec_sigpass_mqc_64x64(t1, bpno_plus_one);
+						  }
+					  }
+					  break;
+				  case 1:
+					  if (type == T1_TYPE_RAW) {
+							  opj_t1_dec_refpass_raw(t1, bpno_plus_one, (OPJ_INT32)cblksty);
+					  } else {
+						  if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+							  opj_t1_dec_refpass_mqc_vsc(t1, bpno_plus_one);
+						  } else {
+							  opj_t1_dec_refpass_mqc_64x64(t1, bpno_plus_one);
+						  }
+					  }
+					  break;
+				  case 2:
+					  opj_t1_dec_clnpass_64x64(t1, bpno_plus_one, (OPJ_INT32)cblksty);
+					  break;
+			  }
+
+			  if ((cblksty & J2K_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
+				  opj_mqc_resetstates(mqc);
+				  opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+				  opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+				  opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+			  }
+			  if (++passtype == 3) {
+				  passtype = 0;
+				  bpno_plus_one--;
+			  }
+		  }
+		}
+		else
+		{
+		  for (passno = 0; (passno < seg->real_num_passes) && (bpno_plus_one >= 1); ++passno) {
+			  switch (passtype) {
+				  case 0:
+					  if (type == T1_TYPE_RAW) {
+						  opj_t1_dec_sigpass_raw(t1, bpno_plus_one, (OPJ_INT32)cblksty);
+					  } else {
+						  if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+							  opj_t1_dec_sigpass_mqc_vsc(t1, bpno_plus_one);
+						  } else {
+							  opj_t1_dec_sigpass_mqc_generic(t1, bpno_plus_one);
+						  }
+					  }
+					  break;
+				  case 1:
+					  if (type == T1_TYPE_RAW) {
+							  opj_t1_dec_refpass_raw(t1, bpno_plus_one, (OPJ_INT32)cblksty);
+					  } else {
+						  if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+							  opj_t1_dec_refpass_mqc_vsc(t1, bpno_plus_one);
+						  } else {
+							  opj_t1_dec_refpass_mqc_generic(t1, bpno_plus_one);
+						  }
+					  }
+					  break;
+				  case 2:
+					  opj_t1_dec_clnpass_generic(t1, bpno_plus_one, (OPJ_INT32)cblksty);
+					  break;
+			  }
+
+			  if ((cblksty & J2K_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
+				  opj_mqc_resetstates(mqc);
+				  opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+				  opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+				  opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+			  }
+			  if (++passtype == 3) {
+				  passtype = 0;
+				  bpno_plus_one--;
+			  }
+		  }
 		}
 	}
     return OPJ_TRUE;
@@ -1585,6 +1913,8 @@ static void opj_t1_encode_cblk(opj_t1_t *t1,
 	OPJ_BYTE type = T1_TYPE_MQ;
 	OPJ_FLOAT64 tempwmsedec;
 
+	mqc->lut_ctxno_zc_orient = lut_ctxno_zc + orient * 256;
+
 	max = 0;
 	for (i = 0; i < t1->w; ++i) {
 		for (j = 0; j < t1->h; ++j) {
@@ -1611,13 +1941,13 @@ static void opj_t1_encode_cblk(opj_t1_t *t1,
 
 		switch (passtype) {
 			case 0:
-				opj_t1_enc_sigpass(t1, bpno, orient, &nmsedec, type, cblksty);
+				opj_t1_enc_sigpass(t1, bpno, &nmsedec, type, cblksty);
 				break;
 			case 1:
 				opj_t1_enc_refpass(t1, bpno, &nmsedec, type, cblksty);
 				break;
 			case 2:
-				opj_t1_enc_clnpass(t1, bpno, orient, &nmsedec, cblksty);
+				opj_t1_enc_clnpass(t1, bpno, &nmsedec, cblksty);
 				/* code switch SEGMARK (i.e. SEGSYM) */
 				if (cblksty & J2K_CCP_CBLKSTY_SEGSYM)
 					opj_mqc_segmark_enc(mqc);
diff --git a/src/lib/openjp2/t1.h b/src/lib/openjp2/t1.h
index 3bc0ad9..22557d9 100644
--- a/src/lib/openjp2/t1.h
+++ b/src/lib/openjp2/t1.h
@@ -50,6 +50,9 @@ in T1.C are used by some function in TCD.C.
 /* ----------------------------------------------------------------------- */
 #define T1_NMSEDEC_BITS 7
 
+/* CAUTION: the value of those constants must not be changed, otherwise the */
+/* optimization of opj_t1_updateflags() will break! */
+/* BEGINNING of flags that apply to opj_flag_t */
 #define T1_SIG_NE 0x0001	/**< Context orientation : North-East direction */
 #define T1_SIG_SE 0x0002	/**< Context orientation : South-East direction */
 #define T1_SIG_SW 0x0004	/**< Context orientation : South-West direction */
@@ -67,9 +70,10 @@ in T1.C are used by some function in TCD.C.
 #define T1_SGN_W 0x0800
 #define T1_SGN (T1_SGN_N|T1_SGN_E|T1_SGN_S|T1_SGN_W)
 
-#define T1_SIG 0x1000
-#define T1_REFINE 0x2000
-#define T1_VISIT 0x4000
+#define T1_SIG 0x1000		/**< No longer used by decoder */
+#define T1_REFINE 0x2000	/**< No longer used by decoder */
+#define T1_VISIT 0x4000		/**< No longer used by decoder */
+/* END of flags that apply to opj_flag_t */
 
 #define T1_NUMCTXS_ZC 9
 #define T1_NUMCTXS_SC 5
@@ -89,10 +93,32 @@ in T1.C are used by some function in TCD.C.
 #define T1_TYPE_MQ 0	/**< Normal coding using entropy coder */
 #define T1_TYPE_RAW 1	/**< No encoding the information is store under raw format in codestream (mode switch RAW)*/
 
+/* Those flags are used by opj_colflag_t */
+#define T1_COLFLAG_RBS				4 /* RBS = Row Bit Shift */
+#define T1_COLFLAG_SIG_OTHER_ROW_0	(1 << 0)  /**< This sample has at least one significant neighbour */
+#define T1_COLFLAG_SIG_ROW_0		(1 << 1)  /**< This sample is significant */
+#define T1_COLFLAG_VISIT_ROW_0		(1 << 2)  /**< This sample has been visited */
+#define T1_COLFLAG_REFINE_ROW_0		(1 << 3)  /**< This sample has been refined */
+#define T1_COLFLAG_SIG_OTHER_ROW_1	(T1_COLFLAG_SIG_OTHER_ROW_0 << T1_COLFLAG_RBS)
+#define T1_COLFLAG_SIG_ROW_1		(T1_COLFLAG_SIG_ROW_0 << T1_COLFLAG_RBS)
+#define T1_COLFLAG_VISIT_ROW_1		(T1_COLFLAG_VISIT_ROW_0 << T1_COLFLAG_RBS)
+#define T1_COLFLAG_REFINE_ROW_1		(T1_COLFLAG_REFINE_ROW_0 << T1_COLFLAG_RBS)
+#define T1_COLFLAG_SIG_OTHER_ROW_2	(T1_COLFLAG_SIG_OTHER_ROW_0 << (2*T1_COLFLAG_RBS))
+#define T1_COLFLAG_SIG_ROW_2		(T1_COLFLAG_SIG_ROW_0 << (2*T1_COLFLAG_RBS))
+#define T1_COLFLAG_VISIT_ROW_2		(T1_COLFLAG_VISIT_ROW_0 << (2*T1_COLFLAG_RBS))
+#define T1_COLFLAG_REFINE_ROW_2		(T1_COLFLAG_REFINE_ROW_0 << (2*T1_COLFLAG_RBS))
+#define T1_COLFLAG_SIG_OTHER_ROW_3	(T1_COLFLAG_SIG_OTHER_ROW_0 << (3*T1_COLFLAG_RBS))
+#define T1_COLFLAG_SIG_ROW_3		(T1_COLFLAG_SIG_ROW_0 << (3*T1_COLFLAG_RBS))
+#define T1_COLFLAG_VISIT_ROW_3		(T1_COLFLAG_VISIT_ROW_0 << (3*T1_COLFLAG_RBS))
+#define T1_COLFLAG_REFINE_ROW_3		(T1_COLFLAG_REFINE_ROW_0 << (3*T1_COLFLAG_RBS))
+
 /* ----------------------------------------------------------------------- */
 
 typedef OPJ_INT16 opj_flag_t;
 
+/** Flags for 4 consecutive rows of a column */
+typedef OPJ_UINT16 opj_colflag_t;
+
 /**
 Tier-1 coding (coding of code-block coefficients)
 */
@@ -105,11 +131,17 @@ typedef struct opj_t1 {
 
 	OPJ_INT32  *data;
 	opj_flag_t *flags;
+	/** Addition flag array such that colflags[1+0] is for state of col=0,row=0..3,
+	   colflags[1+1] for col=1, row=0..3, colflags[1+flags_stride] for col=0,row=4..7, ... 
+	   This array avoids too much cache trashing when processing by 4 vertical samples
+	   as done in the various decoding steps. */
+	opj_colflag_t* colflags;
 	OPJ_UINT32 w;
 	OPJ_UINT32 h;
 	OPJ_UINT32 datasize;
 	OPJ_UINT32 flagssize;
 	OPJ_UINT32 flags_stride;
+	OPJ_UINT32 colflags_size;
 	OPJ_UINT32 data_stride;
 	OPJ_BOOL   encoder;
 } opj_t1_t;
diff --git a/src/lib/openjp2/t1_generate_luts.c b/src/lib/openjp2/t1_generate_luts.c
index cba7245..1e6e7b0 100644
--- a/src/lib/openjp2/t1_generate_luts.c
+++ b/src/lib/openjp2/t1_generate_luts.c
@@ -216,7 +216,7 @@ int main(int argc, char **argv)
 		}
 	}
 
-	printf("static OPJ_BYTE lut_ctxno_zc[1024] = {\n  ");
+	printf("static const OPJ_BYTE lut_ctxno_zc[1024] = {\n  ");
 	for (i = 0; i < 1023; ++i) {
 		printf("%i, ", lut_ctxno_zc[i]);
 		if(!((i+1)&0x1f))
@@ -225,7 +225,7 @@ int main(int argc, char **argv)
 	printf("%i\n};\n\n", lut_ctxno_zc[1023]);
 
 	/* lut_ctxno_sc */
-	printf("static OPJ_BYTE lut_ctxno_sc[256] = {\n  ");
+	printf("static const OPJ_BYTE lut_ctxno_sc[256] = {\n  ");
 	for (i = 0; i < 255; ++i) {
 		printf("0x%x, ", t1_init_ctxno_sc(i << 4));
 		if(!((i+1)&0xf))
@@ -234,7 +234,7 @@ int main(int argc, char **argv)
 	printf("0x%x\n};\n\n", t1_init_ctxno_sc(255 << 4));
 
 	/* lut_spb */
-	printf("static OPJ_BYTE lut_spb[256] = {\n  ");
+	printf("static const OPJ_BYTE lut_spb[256] = {\n  ");
 	for (i = 0; i < 255; ++i) {
 		printf("%i, ", t1_init_spb(i << 4));
 		if(!((i+1)&0x1f))
@@ -268,16 +268,16 @@ int main(int argc, char **argv)
 					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
 	}
 
-	printf("static OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static const OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(lut_nmsedec_sig, 1 << T1_NMSEDEC_BITS);
 
-	printf("static OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static const OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(lut_nmsedec_sig0, 1 << T1_NMSEDEC_BITS);
 
-	printf("static OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static const OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(lut_nmsedec_ref, 1 << T1_NMSEDEC_BITS);
 
-	printf("static OPJ_INT16 lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static const OPJ_INT16 lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(lut_nmsedec_ref0, 1 << T1_NMSEDEC_BITS);
 
 	return 0;
diff --git a/src/lib/openjp2/t1_luts.h b/src/lib/openjp2/t1_luts.h
index 37776b6..c66a8ae 100644
--- a/src/lib/openjp2/t1_luts.h
+++ b/src/lib/openjp2/t1_luts.h
@@ -1,6 +1,6 @@
 /* This file was automatically generated by t1_generate_luts.c */
 
-static OPJ_BYTE lut_ctxno_zc[1024] = {
+static const OPJ_BYTE lut_ctxno_zc[1024] = {
   0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
   5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
@@ -35,7 +35,7 @@ static OPJ_BYTE lut_ctxno_zc[1024] = {
   2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8
 };
 
-static OPJ_BYTE lut_ctxno_sc[256] = {
+static const OPJ_BYTE lut_ctxno_sc[256] = {
   0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd, 
   0x9, 0xa, 0xc, 0xb, 0xa, 0x9, 0xd, 0xc, 0xc, 0xb, 0xc, 0xb, 0xd, 0xc, 0xd, 0xc, 
   0x9, 0xa, 0xc, 0xb, 0xa, 0xa, 0xb, 0xb, 0xc, 0xd, 0x9, 0xa, 0xd, 0xd, 0xa, 0xa, 
@@ -54,7 +54,7 @@ static OPJ_BYTE lut_ctxno_sc[256] = {
   0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd
 };
 
-static OPJ_BYTE lut_spb[256] = {
+static const OPJ_BYTE lut_spb[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
   0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 
   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
@@ -65,7 +65,7 @@ static OPJ_BYTE lut_spb[256] = {
   0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
 };
 
-static OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
+static const OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
@@ -84,7 +84,7 @@ static OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
   0x6c00, 0x6d80, 0x6f00, 0x7080, 0x7200, 0x7380, 0x7500, 0x7680
 };
 
-static OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
+static const OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0080, 
   0x0080, 0x0080, 0x0100, 0x0100, 0x0100, 0x0180, 0x0180, 0x0200, 
   0x0200, 0x0280, 0x0280, 0x0300, 0x0300, 0x0380, 0x0400, 0x0400, 
@@ -103,7 +103,7 @@ static OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
   0x7080, 0x7280, 0x7480, 0x7600, 0x7800, 0x7a00, 0x7c00, 0x7e00
 };
 
-static OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
+static const OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
   0x1800, 0x1780, 0x1700, 0x1680, 0x1600, 0x1580, 0x1500, 0x1480, 
   0x1400, 0x1380, 0x1300, 0x1280, 0x1200, 0x1180, 0x1100, 0x1080, 
   0x1000, 0x0f80, 0x0f00, 0x0e80, 0x0e00, 0x0d80, 0x0d00, 0x0c80, 
@@ -122,7 +122,7 @@ static OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
   0x1400, 0x1480, 0x1500, 0x1580, 0x1600, 0x1680, 0x1700, 0x1780
 };
 
-static OPJ_INT16 lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {
+static const OPJ_INT16 lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {
   0x2000, 0x1f00, 0x1e00, 0x1d00, 0x1c00, 0x1b00, 0x1a80, 0x1980, 
   0x1880, 0x1780, 0x1700, 0x1600, 0x1500, 0x1480, 0x1380, 0x1300, 
   0x1200, 0x1180, 0x1080, 0x1000, 0x0f00, 0x0e80, 0x0e00, 0x0d00, 
