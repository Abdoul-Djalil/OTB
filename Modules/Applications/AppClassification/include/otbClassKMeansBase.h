/*
 * Copyright (C) 2005-2017 Centre National d'Etudes Spatiales (CNES)
 *
 * This file is part of Orfeo Toolbox
 *
 *     https://www.orfeo-toolbox.org/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef otbClassKMeansBase_h
#define otbClassKMeansBase_h

#include "otbWrapperCompositeApplication.h"
#include "otbWrapperApplicationFactory.h"

#include "otbOGRDataToSamplePositionFilter.h"

namespace otb
{
namespace Wrapper
{

/** \class ClassKMeansBase
 * \brief Base class for the KMeansClassification
 *
 * This class intends to hold common input/output parameters and
 * composite application connection.
 * 
 * KMeansClassification = ImageEnveloppe + PolygonClassStatistics + 
 *                        SampleSelection + SamplesExtraction + 
 *                        ComputeImagesStatistics +
 *                        TrainVectorClassifier + ImageClassifier.
 *
 * \ingroup OTBAppClassification
 */
class ClassKMeansBase : public CompositeApplication
{
public:
  /** Standard class typedefs. */
  typedef ClassKMeansBase Self;
  typedef CompositeApplication Superclass;
  typedef itk::SmartPointer<Self> Pointer;
  typedef itk::SmartPointer<const Self> ConstPointer;


  /** Standard macro */
  itkTypeMacro( ClassKMeansBase, Superclass )
  
  protected:
    class KMeansFileNamesHandler;

    void initKMParams();
    void InitKMSampling();
    void InitKMClassification();

    void ShareKMSamplingParameters();
    void ShareKMClassificationParams();
    void ConnectKMSamplingParams();
    void ConnectKMClassificationParams();
    void ConnectKMClassificationMask();

    /**
     *  Create a vector file (envelope image)
     * \param vectorFile vector file
     * */
    void ComputeImageEnvelope(const std::string &vectorFile);

    /** 
     *  Add field in the layer (ImageEnvelope output)
     * \param vectorFile vector file
     * \param fieldName field name
     * */
    void ComputeAddField(const std::string &vectorFile, const std::string &fieldName);

  /**
   * Compute polygon statistics given provided strategy with PolygonClassStatistics class
   * \param statisticsFileName statistics out file name
   * \param fieldName field name
   */
    void ComputePolygonStatistics(const std::string &statisticsFileName,
                                  const std::string &fieldName);

  /**
   * Select samples by constant strategy
   * \param statisticsFileName statistics out file name
   * \param fieldName field name
   * \param sampleFileName samples select output filename
   * \param sampleExtractFileName samples extract filename
   */
    void SelectAndExtractSamples(const std::string &statisticsFileName,
                                 const std::string &fieldName,
                                 const std::string &sampleFileName,
                                 int NBSamples);

  /**
   * Train the model
   * \param image input image
   * \param sampleTrainFileName samples to train filename (SampleExtraction output)
   * \param modelFileName model filename
   */
    void TrainKMModel(FloatVectorImageType *image,
                      const std::string &sampleTrainFileName,
                      const std::string &modelFileName);

  /**
   * Compute image second order statistics
   * \param imageFileName input image filename
   * \param imagesStatsFileName image statistics
   */
    void ComputeImageStatistics(const std::string &imageFileName,
                                const std::string &imagesStatsFileName);

  /**
   * Performs a classification of the input image according to a model file
   */
    void KMeansClassif();

  /**
   * Write in the output file the centroids positions
   *    class1Dim1 .. class1DimN
   *    ...              ...
   *    classMDim1 .. classMDimN
   * \param image input image
   * \param modelFileName model filename
   * \param nbClasses number of class
   */
    void CreateOutMeansFile(FloatVectorImageType *image, const std::string &modelFileName,
                            unsigned int nbClasses);

    /**
   * \class KMeansFileNamesHandler
   * This class is used to store file names requires for the application's input and output.
   * And to clear temporary files generated by the applications
   * \ingroup OTBAppClassification
   */
    class KMeansFileNamesHandler
      {
      public :
        void CreateTemporaryFileNames(const std::string &outPath)
        {
          tmpVectorFile = outPath + "_imgEnvelope.shp";
          polyStatOutput = outPath + "_polyStats.xml";
          sampleOutput = outPath + "_sampleSelect.shp";
          modelFile = outPath + "_model.txt";
          imgStatOutput = outPath + "_imgstats.xml";
        }

        void clear()
        {
          RemoveFile(tmpVectorFile);
          RemoveFile(polyStatOutput);
          RemoveFile(sampleOutput);
          RemoveFile(modelFile);
          RemoveFile(imgStatOutput);
        }

        std::string tmpVectorFile;
        std::string polyStatOutput;
        std::string sampleOutput;
        std::string modelFile;
        std::string imgStatOutput;

      private:
        bool RemoveFile(const std::string &filePath)
        {
          bool res = true;
          if( itksys::SystemTools::FileExists( filePath.c_str() ) )
            {
            size_t posExt = filePath.rfind( '.' );
            if( posExt != std::string::npos && filePath.compare( posExt, std::string::npos, ".shp" ) == 0 )
              {
              std::string shxPath = filePath.substr( 0, posExt ) + std::string( ".shx" );
              std::string dbfPath = filePath.substr( 0, posExt ) + std::string( ".dbf" );
              std::string prjPath = filePath.substr( 0, posExt ) + std::string( ".prj" );
              RemoveFile( shxPath );
              RemoveFile( dbfPath );
              RemoveFile( prjPath );
              }
            res = itksys::SystemTools::RemoveFile( filePath.c_str() );
            if( !res )
              {
              //otbAppLogINFO( <<"Unable to remove file  "<<filePath );
              }
            }
          return res;
        }

     };

};

} // end namespace Wrapper
} // end namespace otb

#ifndef OTB_MANUAL_INSTANTIATION
#include "otbClassKMeansBase.txx"
#endif

#endif //otbClassKMeansBase_h
