/*
 * Copyright (C) 2005-2017 Centre National d'Etudes Spatiales (CNES)
 *
 * This file is part of Orfeo Toolbox
 *
 *     https://www.orfeo-toolbox.org/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef otbClassKMeansBase_h
#define otbClassKMeansBase_h

#include "otbVectorDataFileWriter.h"
#include "otbWrapperCompositeApplication.h"
#include "otbWrapperApplicationFactory.h"

#include "otbStatisticsXMLFileWriter.h"
#include "otbImageToEnvelopeVectorDataFilter.h"
#include "otbOGRDataToSamplePositionFilter.h"

namespace otb
{
namespace Wrapper
{

/** \class ClassKMeansBase
 * \brief Base class for the KMeansClassification
 *
 *  TODO
 *
 * \ingroup OTBAppClassification
 */
class ClassKMeansBase : public CompositeApplication
{
public:
  /** Standard class typedefs. */
  typedef ClassKMeansBase Self;
  typedef CompositeApplication Superclass;
  typedef itk::SmartPointer<Self> Pointer;
  typedef itk::SmartPointer<const Self> ConstPointer;


  /** Standard macro */
  itkTypeMacro( ClassKMeansBase, Superclass )
  
  protected:
    class KMeansFileNamesHandler;

    void initKMParams();
    void InitKMSampling();
    void InitKMClassification();

    void ShareKMSamplingParameters();
    void ShareKMClassificationParams();
    void ConnectKMSamplingParams();
    void ConnectKMClassificationParams();
    void ConnectKMClassificationMask();

    /**
     *  Create a vector file (envelope image)
     * \param vectorFile vector file
     * */
    void ComputeImageEnvelope(const std::string &vectorFile);

    /** 
     *  add field in the layer (ImageEnvelope output)
     * \param vectorFile vector file
     * \param fieldName field name
     * */
    void ComputeAddField(const std::string &vectorFile, const std::string &fieldName);

  /**
   * Compute polygon statistics given provided strategy with PolygonClassStatistics class
   * \param statisticsFileName statistics out file name
   * \param fieldName field name
   */
    void ComputePolygonStatistics(const std::string &statisticsFileName,
                                  const std::string &fieldName);

  /**
   * Select samples by constant strategy
   * \param sampleFileName
   * \param statisticsFileName
   * \param fieldName
   * \param sampleExtractFileName
   */
    void SelectAndExtractSamples(std::string sampleFileName,
                                 std::string statisticsFileName,
                                 std::string fieldName,
                                 std::string sampleExtractFileName,
                                 int NBSamples);

  /**
   * Train the model
   * \param image input image
   * \param sampleTrainFileName
   */
    void TrainKMModel(FloatVectorImageType *image,
                      std::string sampleTrainFileName,
                      std::string modelFileName);

  /**
   * Performs a classification of the input image according to a model file
   */
    void KMeansClassif();

    /**
   * \class KMeansFileNamesHandler
   * This class is used to store file names requires for the application's input and output.
   * And to clear temporary files generated by the applications
   * \ingroup OTBAppClassification
   */
    class KMeansFileNamesHandler
      {
      public :
        void CreateTemporaryFileNames(std::string outPath)
        {
          tmpVectorFile = outPath + "_imgEnvelope.shp";
          polyStatOutput = outPath + "_polyStats.xml";
          sampleSelectOutput = outPath + "_sampleSelect.shp";
          sampleExtractOutput = outPath + "_sampleExtract.shp";
          modelFile = outPath + "_model.txt";
        }

        void clear()
        {
          RemoveFile(tmpVectorFile);
          RemoveFile(polyStatOutput);
          RemoveFile(sampleSelectOutput);
          RemoveFile(sampleExtractOutput);
          RemoveFile(modelFile);
        }

        std::string tmpVectorFile;
        std::string polyStatOutput;
        std::string sampleSelectOutput;
        std::string sampleExtractOutput;
        std::string modelFile;

      private:
        bool RemoveFile(std::string &filePath)
        {
          bool res = true;
          if( itksys::SystemTools::FileExists( filePath.c_str() ) )
            {
            size_t posExt = filePath.rfind( '.' );
            if( posExt != std::string::npos && filePath.compare( posExt, std::string::npos, ".shp" ) == 0 )
              {
              std::string shxPath = filePath.substr( 0, posExt ) + std::string( ".shx" );
              std::string dbfPath = filePath.substr( 0, posExt ) + std::string( ".dbf" );
              std::string prjPath = filePath.substr( 0, posExt ) + std::string( ".prj" );
              RemoveFile( shxPath );
              RemoveFile( dbfPath );
              RemoveFile( prjPath );
              }
            res = itksys::SystemTools::RemoveFile( filePath.c_str() );
            if( !res )
              {
              //otbAppLogINFO( <<"Unable to remove file  "<<filePath );
              }
            }
          return res;
        }

     };

};

} // end namespace Wrapper
} // end namespace otb

#ifndef OTB_MANUAL_INSTANTIATION
#include "otbClassKMeansBase.txx"
#endif

#endif //otbClassKMeansBase_h
