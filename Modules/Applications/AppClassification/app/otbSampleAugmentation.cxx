/*
 * Copyright (C) 2005-2017 Centre National d'Etudes Spatiales (CNES)
 *
 * This file is part of Orfeo Toolbox
 *
 *     https://www.orfeo-toolbox.org/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "otbWrapperApplication.h"
#include "otbWrapperApplicationFactory.h"
#include "otbOGRDataSourceWrapper.h"
#include "otbSampleAugmentation.h"

namespace otb
{
namespace Wrapper
{


class SampleAugmentation : public Application
{
public:
  /** Standard class typedefs. */
  typedef SampleAugmentation              Self;
  typedef Application                   Superclass;
  typedef itk::SmartPointer<Self>       Pointer;
  typedef itk::SmartPointer<const Self> ConstPointer;

  /** Standard macro */
  itkNewMacro(Self);

  itkTypeMacro(SampleAugmentation, otb::Application);

  /** Filters typedef */
  using SampleType = sampleAugmentation::SampleType;
  using SampleVectorType = sampleAugmentation::SampleVectorType;


private:
  SampleAugmentation() {}

  void DoInit()
  {
    SetName("SampleAugmentation");
    SetDescription("Generates synthetic samples from a sample data file.");

    // Documentation
    SetDocName("Sample Extraction");
    SetDocLongDescription("The application takes a sample data file as "
                          "generated by the SampleExtraction application and "
                          "generates synthetic samples to increase the number of "
                          "available samples.");
    SetDocLimitations("None");
    SetDocAuthors("OTB-Team");
    SetDocSeeAlso(" ");

    AddDocTag(Tags::Learning);

    AddParameter(ParameterType_InputFilename, "in", "Input samples");
    SetParameterDescription("in","Vector data file containing samples (OGR format)");

    AddParameter(ParameterType_OutputFilename, "out", "Output samples");
    SetParameterDescription("out","Output vector data file storing new samples"
                            "(OGR format). If not given, the input vector data file is updated");
    MandatoryOff("out");

    AddParameter(ParameterType_ListView, "field", "Field Name");
    SetParameterDescription("field","Name of the field carrying the class name in the input vectors.");
    SetListViewSingleSelectionMode("field",true);
    
    AddParameter(ParameterType_Int, "layer", "Layer Index");
    SetParameterDescription("layer", "Layer index to read in the input vector file.");
    MandatoryOff("layer");
    SetDefaultParameterInt("layer",0);

    AddParameter(ParameterType_Int, "label", "Label of the class to be augmented");
    SetParameterDescription("label", "Label of the class of the input file for which "
                            "new samples will be generated.");
    SetDefaultParameterInt("label",1);

    AddParameter(ParameterType_Int, "samples", "Number of generated samples");
    SetParameterDescription("samples", "Number of synthetic samples that will "
                            "be generated.");
    SetDefaultParameterInt("samples",100);

    AddParameter(ParameterType_ListView, "exclude", "Field names for excluded features.");
    SetParameterDescription("exclude",
                            "List of field names in the input vector data that will not be generated in the output file.");

    AddParameter(ParameterType_Choice, "strategy", "Augmentation strategy");

    AddChoice("strategy.replicate","Replicate input samples");
    SetParameterDescription("strategy.replicate","The new samples are generated "
                            "by replicating input samples which are randomly "
                            "selected with replacement.");

    AddChoice("strategy.jitter","Jitter input samples");
    SetParameterDescription("strategy.jitter","The new samples are generated "
                            "by adding gaussian noise to input samples which are "
                            "randomly selected with replacement.");
    AddParameter(ParameterType_Float, "strategy.jitter.stdfactor", 
                 "Factor for dividing the standard deviation of each feature");
    SetParameterDescription("strategy.jitter.stdfactor", 
                            "The noise added to the input samples will have the "
                            "standard deviation of the input features divided "
                            "by the value of this parameter. ");
    SetDefaultParameterFloat("strategy.jitter.stdfactor",10000);

    AddChoice("strategy.smote","Smote input samples");
    SetParameterDescription("strategy.smote","The new samples are generated "
                            "by using the SMOTE algorithm (http://dx.doi.org/10.1613/jair.953) "
                            "on input samples which are "
                            "randomly selected with replacement.");
    AddParameter(ParameterType_Int, "strategy.smote.neighbors", 
                 "Number of nearest neighbors.");
    SetParameterDescription("strategy.smote.neighbors", 
                            "Number of nearest neighbors to be used in the "
                            "SMOTE algorithm");
    SetDefaultParameterFloat("strategy.smote.neighbors", 5);

    AddParameter(ParameterType_Int, "seed", 
                 "Random seed.");
    SetParameterDescription("seed", 
                            "Seed for the random number generator.");
    MandatoryOff("seed");

    // Doc example parameter settings
    SetDocExampleParameterValue("in", "samples.sqlite");
    SetDocExampleParameterValue("field", "class");
    SetDocExampleParameterValue("label", "3");
    SetDocExampleParameterValue("samples", "100");
    SetDocExampleParameterValue("out","augmented_samples.sqlite");
    SetDocExampleParameterValue( "exclude", "OGC_FID name class originfid" );
    SetDocExampleParameterValue("strategy", "smote");
    SetDocExampleParameterValue("strategy.smote.neighbors", "5");

    SetOfficialDocLink();
  }

  void DoUpdateParameters()
  {
    if ( HasValue("in") )
      {
      std::string vectorFile = GetParameterString("in");
      ogr::DataSource::Pointer ogrDS =
        ogr::DataSource::New(vectorFile, ogr::DataSource::Modes::Read);
      ogr::Layer layer = ogrDS->GetLayer(this->GetParameterInt("layer"));
      ogr::Feature feature = layer.ogr().GetNextFeature();

      ClearChoices("exclude");
      ClearChoices("field");
      
      for(int iField=0; iField<feature.ogr().GetFieldCount(); iField++)
        {
        std::string key, item = feature.ogr().GetFieldDefnRef(iField)->GetNameRef();
        key = item;
        std::string::iterator end = std::remove_if(key.begin(),key.end(),
                                                   [](auto c){return !std::isalnum(c);});
        std::transform(key.begin(), end, key.begin(), tolower);
        
        OGRFieldType fieldType = feature.ogr().GetFieldDefnRef(iField)->GetType();
        
        if(fieldType == OFTString || fieldType == OFTInteger || ogr::version_proxy::IsOFTInteger64(fieldType))
          {
          std::string tmpKey="field."+key.substr(0, end - key.begin());
          AddChoice(tmpKey,item);
          }
        if( fieldType == OFTInteger || ogr::version_proxy::IsOFTInteger64( fieldType ) || fieldType == OFTReal )
          {
          std::string tmpKey = "exclude." + key.substr( 0, static_cast<unsigned long>( end - key.begin() ) );
          AddChoice( tmpKey, item );
          }
        }
      }
  }

  void DoExecute()
    {
    ogr::DataSource::Pointer vectors;
    ogr::DataSource::Pointer output;
    if (IsParameterEnabled("out") && HasValue("out"))
      {
      vectors = ogr::DataSource::New(this->GetParameterString("in"));
      output = ogr::DataSource::New(this->GetParameterString("out"),
                                    ogr::DataSource::Modes::Overwrite);
      }
    else
      {
      // Update mode
      vectors = ogr::DataSource::New(this->GetParameterString("in"),
                                     ogr::DataSource::Modes::Update_LayerUpdate);
      output = vectors;
      }

    // Retrieve the field name
    std::vector<int> selectedCFieldIdx = GetSelectedItems("field");

    if(selectedCFieldIdx.empty())
      {
      otbAppLogFATAL(<<"No field has been selected for data labelling!");
      }

  std::vector<std::string> cFieldNames = GetChoiceNames("field");  
  std::string fieldName = cFieldNames[selectedCFieldIdx.front()];
    
  std::vector<std::string> excludedFeatures = 
    GetExcludedFeatures( GetChoiceNames( "exclude" ), 
                         GetSelectedItems( "exclude" ));
  for(const auto& ef : excludedFeatures)
    otbAppLogINFO("Excluding feature " << ef << '\n');
  auto inSamples = extractSamples(vectors, this->GetParameterInt("layer"),
                                  fieldName,
                                  this->GetParameterInt("label"),
                                  excludedFeatures);
  int seed = std::time(nullptr);
  if(IsParameterEnabled("seed")) seed = this->GetParameterInt("seed");
  SampleVectorType newSamples;
  switch (this->GetParameterInt("strategy"))
    {
    // replicate
    case 0:
    {
    otbAppLogINFO("Augmentation strategy : replicate");
    sampleAugmentation::replicateSamples(inSamples, this->GetParameterInt("samples"),
                                         newSamples);
    }
    break;
    // jitter
    case 1:
    {
    otbAppLogINFO("Augmentation strategy : jitter");
    sampleAugmentation::jitterSamples(inSamples, this->GetParameterInt("samples"),
                                      newSamples,
                                      this->GetParameterFloat("strategy.jitter.stdfactor"),
                                      seed);
    }
    break;
    case 2:
    {
    otbAppLogINFO("Augmentation strategy : smote");
    sampleAugmentation::smote(inSamples, this->GetParameterInt("samples"),
                              newSamples,
                              this->GetParameterInt("strategy.smote.neighbors"),
                              seed);
    }
    break;
    }
  writeSamples(vectors, output, newSamples, this->GetParameterInt("layer"),
               fieldName,
               this->GetParameterInt("label"),
               excludedFeatures);
  output->SyncToDisk();
    }

/** Extracts the samples of a single class from the vector data to a
* vector and excludes some unwanted features.
*/
  SampleVectorType extractSamples(const ogr::DataSource::Pointer vectors, 
                                  size_t layerName,
                                  const std::string& classField, const int label,
                                  const std::vector<std::string>& excludedFeatures = {})
  {
    ogr::Layer layer = vectors->GetLayer(layerName);
    ogr::Feature feature = layer.ogr().GetNextFeature();
    if(feature.addr() == 0)
      {
      otbAppLogFATAL("Layer " << layerName << " of input sample file is empty.\n");
      }
    int cFieldIndex = feature.ogr().GetFieldIndex( classField.c_str() );
    if( cFieldIndex < 0 )
      {
      otbAppLogFATAL( "The field name for class label (" << classField
                      << ") has not been found in the vector file " );
      }

    auto numberOfFields = feature.ogr().GetFieldCount();
    auto excludedIds = getExcludedFeaturesIds(excludedFeatures, layer);
    otbAppLogINFO("The vector file contains " << numberOfFields << " fields.\n");
    SampleVectorType samples;
    bool goesOn{feature.addr() != 0};
    while( goesOn )
      {
      // Retrieve all the features for each field in the ogr layer.
      if(feature.ogr().GetFieldAsInteger(classField.c_str()) == label)
        {

        SampleType mv;
        for(auto idx=0; idx<numberOfFields; ++idx)
          {
          if(excludedIds.find(idx) == excludedIds.cend() &&
             isNumericField(feature, idx))
            mv.push_back(feature.ogr().GetFieldAsDouble(idx));
          }
        samples.push_back(mv); 
        }
      feature = layer.ogr().GetNextFeature();
      goesOn = feature.addr() != 0;
      }
    return samples;
  }

  void writeSamples(const ogr::DataSource::Pointer& vectors,
                    ogr::DataSource::Pointer& output, 
                    const SampleVectorType& samples,
                    const size_t layerName,
                    const std::string& classField, int label,
                    const std::vector<std::string>& excludedFeatures = {})
  {

    auto inputLayer = vectors->GetLayer(layerName);
    auto excludedIds = getExcludedFeaturesIds(excludedFeatures, inputLayer);

    OGRSpatialReference * oSRS = nullptr;
    if (inputLayer.GetSpatialRef())
      {
      oSRS = inputLayer.GetSpatialRef()->Clone();
      }
    OGRFeatureDefn &layerDefn = inputLayer.GetLayerDefn();

    auto outputLayer = output->CreateLayer(inputLayer.GetName(), oSRS, 
                                           inputLayer.GetGeomType());
    for (int k=0 ; k < layerDefn.GetFieldCount() ; k++)
      {
      OGRFieldDefn originDefn(layerDefn.GetFieldDefn(k));
      ogr::FieldDefn fieldDefn(originDefn);
      outputLayer.CreateField(fieldDefn);
      }

    auto featureCount = outputLayer.GetFeatureCount(false);
    auto templateFeature = selectTemplateFeature(inputLayer, classField, label);
    for(const auto& sample : samples)
         {
         ogr::Feature dstFeature(outputLayer.GetLayerDefn());
         dstFeature.SetFrom( templateFeature, TRUE );
         dstFeature.SetFID(++featureCount);
         auto sampleFieldCounter = 0;
         for (int k=0 ; k < layerDefn.GetFieldCount() ; k++)
           {
           if(excludedIds.find(k) == excludedIds.cend() &&
              isNumericField(dstFeature, k))
             {
             dstFeature.ogr().SetField(k, sample[sampleFieldCounter++]);
             }
           }
         outputLayer.CreateFeature( dstFeature );
         }
  }

  std::vector<std::string> GetExcludedFeatures(const std::vector<std::string>& fieldNames,
                                               const std::vector<int>& selectedIdx)
  {
    auto nbFeatures = static_cast<unsigned int>(selectedIdx.size());
    std::vector<std::string> result( nbFeatures );
    for( unsigned int i = 0; i < nbFeatures; ++i )
      {
      result[i] = fieldNames[selectedIdx[i]];
      }
    return result;
  }
  ogr::Feature selectTemplateFeature(const ogr::Layer& inputLayer, 
                                     const std::string& classField, int label)
  {
    auto featureIt = inputLayer.begin();
    bool goesOn{(*featureIt).addr() != 0};
    while( goesOn )
      {
      if((*featureIt).ogr().GetFieldAsInteger(classField.c_str()) == label)
        {
        return *featureIt;
        }
      ++featureIt;
      }
    return *(inputLayer.begin());
  }
  std::set<size_t> getExcludedFeaturesIds(const std::vector<std::string>& excludedFeatures,
                                          const ogr::Layer& inputLayer)
  {
    auto feature = *(inputLayer).begin();
    std::set<size_t> excludedIds;
    if( excludedFeatures.size() != 0)
      {
      for(const auto& fieldName : excludedFeatures)
        {
        auto idx = feature.ogr().GetFieldIndex( fieldName.c_str() );
        excludedIds.insert(idx);
        }
      }
    return excludedIds;
  }
  bool isNumericField(const ogr::Feature& feature,
                      const int idx)
  {
    OGRFieldType fieldType = feature.ogr().GetFieldDefnRef(idx)->GetType();
    return (fieldType == OFTInteger 
            || ogr::version_proxy::IsOFTInteger64( fieldType ) 
            || fieldType == OFTReal);
  }
  };

} // end of namespace Wrapper
} // end of namespace otb

OTB_APPLICATION_EXPORT(otb::Wrapper::SampleAugmentation)
